\documentclass[runningheads]{llncs}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
%%%%
\usepackage{color}
\usepackage{alltt}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage[cp1252]{inputenc}
\usepackage[spanish]{babel}
%%
\usepackage{url}
\hyphenation{Map-Re-du-ce}
\urldef{\mailsa}\path|munozs.88@gmail.com,{pgarcia,pedro,mgarenas}@atc.ugr.es,{amorag,jmerelo}@geneura.ugr.es|

\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\begin{document}
 \pagestyle{empty} %ESTO QUITA LOS N03MEROS DE P09GINA
\mainmatter  % start of an individual contribution

% first the title is needed
\title{Estudio sobre algoritmos genticos en la nube y el modelo de programacin MapReduce\thanks{Financiado con los proyectos EvOrq (TIC-3903), Beca FPU AP2009-2942, ANYSELF (TIN2011-28627-C04-02) y CANUBE (Proyecto 83 CEI-BIOTIC). }}

% Mete tambi?n el del ministerio, que estaba vigente cuando el PFC. 

% a short form should be given in case it is too long for the running head
\titlerunning{Estudio sobre AGs en la nube}

% the name(s) of the author(s) follow(s) next
%
% NB: Chinese authors should write their first names(s) in front of
% their surnames. This ensures that the names appear correctly in
% the running heads and the author index.
%
\author{G. Mu\~noz  \and P. Garc\'ia-S\'anchez  \and P. A. Castillo \and M. G. Arenas \and A. M. Mora  \and J. J. Merelo \inst{1}}
%
\authorrunning{P. Garc\'ia-S\'anchez et al.}
% (feature abused for this document to repeat the title also on left hand pages)

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
\institute{Dpto. de Arquitectura y Tecnologa de los Computadores, Universidad de Granada\\
\mailsa}


%
% NB: a more complex sample for affiliations and the mapping to the
% corresponding authors can be found in the file "llncs.dem"
% (search for the string "\mainmatter" where a contribution starts).
% "llncs.dem" accompanies the document class "llncs.cls".
%

\toctitle{Estudio sobre algoritmos genticos en la nube y el modelo de programacin MapReduce}
\tocauthor{Authors' Instructions}
\maketitle


\begin{abstract}
Este trabajo presenta el proyecto fin de carrera ``Estudio sobre algoritmos genticos en la nube y el modelo de programacin MapReduce''. Durante el desarrollo de este proyecto se investig en el uso y aplicacin de Algoritmos Genticos en distintos entornos de Cloud Computing, como el MapReduce o virtualizacin de instancias. Se ejecutaron distintas configuraciones de parmetros del algoritmo (como el tamao de poblacin o el tipo de crossover) en distintas instancias de Amazon Web Services. Los resultados muestran el efecto de estos parmetros al tipo de instancia utilizada. 
% si usas computaci贸n nube en el t铆tulo, 煤salo en todos sitios - JJ
% Por otro lado, d铆 cu谩l era el objetivo del trabajo. No puedes
% limitarte a decir "distintas configuraciones de par谩metros" si no
% explicas lo que son, ni para qu茅 sirven, ni siquiera por qu茅 has
% decidido usar computaci贸n nube. FERGU: Aadidos
\vspace{1cm}

\textbf{Abstract} This paper shows the final degree project ``An study of genetic algorithms in the cloud and the MapReduce model''. During the development of this project the usage and application of genetic algorithms in different Cloud Computing environments was investigated, such as MapReduce or virtualization. Different parameter configurations, such as the population size or crossover type, were launched in different instances of Amazon Web Services. Results show the effect of these parameters to the different types of used instances.

\end{abstract}

\keywords{Cloud Computing, Proyecto Fin de Carrera, Amazon EC2, Virtualizacin, MapReduce, Algoritmos Evolutivos}

\section{Introduccin}
\noindent En la ltima dcada Internet ha transformado nuestra economa y nuestra sociedad. Ha demostrado ser una infraestructura de comunicacin 
y enlace de gran valor que se adapta gradualmente a las necesidades de los usuarios. Con Internet se ha creado una red mundial de 
intercambio de conocimientos, creatividad y colaboracin.  % madre m铆a, esta frase es de los 90!!!! - JJ - FERGU: No la he escrito yo, que conste ;)

Del mismo modo, Internet ha dado un gran salto adelante gracias al despliegue de la banda ancha de
alta velocidad, lo que ha permitido el lanzamiento de muchos nuevos servicios interactivos y de
contenido. 

Todo esto hace que los programas informticos ofertados en la red como un servicio disminuyan sus costes y aumenten su eficacia, 
provocando una gran mejora de la productividad. Desplegado adecuadamente, la llamada Internet del
futuro, que cada vez es ms presente, trae consigo innovacin, aumento de la productividad, nuevos
mercados y ms crecimiento y empleo en esta dcada que recin acabamos de comenzar. 

En este marco se engloba el Cloud Computing, un nuevo modelo de negocio en Internet, que beneficia tanto al proveedor de 
servicios en la nube como al usuario, capaz de tener acceso instantneo a una infraestructura
escalable y potente a un coste mnimo.
 
Paralelamente a esta transformacin, la ciencia ha estado evolucionando constantemente durante los ltimos lustros, en gran parte, 
gracias a la aparicin y el uso  de nuevas tecnologas. La investigacin cientfica avanza al
unsono con sta, pues un cambio tecnolgico, la mayora 
de las veces, abre un nuevo abanico de posibilidades para la comunidad cientfica ya sea para el
desarrollo en un mbito clnico, cientfico o industrial, ya que la necesidad de capacidad de
procesamiento de datos es comn al sector en el que se desarrollen.

Por otra parte, el crecimiento de los volmenes de datos a procesar es exponencial, por lo que para
resolver un problema complejo el personal cientfico o investigador tiene que tratar con una
cantidad de informacin ingente. Dentro de estos conjuntos 
de problemas se encuentran los de bsqueda, a menudo abordados por los denominados Algoritmos
Genticos, que se usan cada vez ms en 
escenarios de gran complejidad. 

% si son evidentes, 隆no los digas! 隆No metas m谩s rollo de la cuenta! - JJ - FERGU: lo quito
Sentando estos principios en la sociedad actual, la motivacin de este proyecto fin de
carrera fu el de buscar una aproximacin nueva para 
desarrollar trabajos de investigacin usando las facilidades que nos brinda el Cloud Computing, y concretamente la resolucin de 
problemas de bsqueda representados mediante Algoritmos Genticos, yendo ms all y sentando las
bases de un framework como {\it Hadoop Map Reduce}, para la reduccin de complejidad y tiempo de
procesamiento en los mtodos de bsqueda.

El resto del trabajo se organiza como sigue: primero se define el concepto de Cloud Computing en la
Seccin \ref{sec:cloud}. A continuacin se explican dos tipos de tecnologas a aplicar los
experimentos: {\it Amazon Web Services} y el modelo {\it MapReduce} y  (en las Secciones \ref{sec:aws}
y \ref{sec:mapreduce} , respectivamente). Los Algoritmos genticos se presentan en la Seccin
\ref{sec:ags}. Despus se describen los experimentos a realizar (Seccin \ref{sec:experimentos}) y
el anlisis de sus resultados (Seccin \ref{sec:analisis}). Finalmente se presentan las conclusiones
y trabajo futuro.



\section{Cloud Computing}
\label{sec:cloud}
Cloud computing es an un paradigma en evolucin, sus definiciones, arquitecturas, modelos, casos de uso, tecnologas base, problemas, 
riesgos y beneficios, son continuamente redefinidos en debates promocionados por el sector pblico y
privado. En \cite{Bible2011} 
podemos ver varias  definiciones aunque muchos citan como ms precisa la definicin dada por el
{\it National Institute of Standards and Technology} (NIST), donde se define el {\it Cloud Computing}
como: 

\textit{Cloud Computing es un modelo para habilitar acceso conveniente por demanda a un conjunto compartido de recursos computacionales 
configurables, por ejemplo, redes, servidores, almacenamiento, aplicaciones y servicios, que pueden ser rpidamente proporcionados y 
liberados con un esfuerzo mnimo de administracin o de interaccin con el proveedor de servicios. Este modelo de nube promueve la 
disponibilidad y est compuesto por cinco caractersticas esenciales, tres modelos de servicio y cuatro modelos de despliegue. }


En un intento de adentrarse en lo que es y no es el Cloud computing compararemos este paradigma con
la computacin tradicional. Con la computacin
tradicional ejecutamos copias de software en cada ordenador. 
Los documentos que creamos  son almacenados en el ordenador en el que fueron creados. Aunque se puede acceder a los documentos desde 
otros ordenadores de la red, no se puede desde ordenadores de fuera de ella. 

Con cloud computing, los programas que usamos no se ejecutan en nuestro ordenador personal, sino que son almacenados en servidores 
accedidos va Internet. Si tu ordenador se rompiera, el software seguira estando operativo para los
dems. De la misma forma, los documentos que creamos son almacenados en una coleccin de
servidores en los que un usuario con permiso puede, no slo acceder a los 
documentos, sino tambin editar y colaborar en ellos en tiempo real. A diferencia de la computacin
tradicional, el modelo 
de Cloud no es PC-Cntrico por lo que el dispositivo que se usa para acceder a la informacin no es
lo ms importante. 

A continuacin, veremos qu es Cloud Computing y qu no es \cite{Web08} .

\subsection{Qu no es cloud computing}

Cloud computing no es una red de ordenadores. Con una red, las aplicaciones  y documentos son almacenados en un servidor de la empresa 
y accedidos a travs de la red de la empresa. Cloud computing es mucho ms que esto. Engloba mltiples empresas, mltiples servidores y 
mltiples redes. A diferencia de una red de ordenadores, los servicios cloud y el almacenamiento pueden ser accedidos desde cualquier 
ordenador del mundo con una conexin a internet. 

Cloud computing tampoco es la subcontratacin de un servicio externo de manera tradicional, donde la compa耥a contratada presta sus 
servicios a la empresa contratadora. Mientras una empresa de outsourcing organiza sus datos y aplicaciones, estos documentos y 
programas solamente son accesibles a los empleados de la empresa a travs de la red de la misma, no a todo el mundo va internet.
As que, a pesar de las aparentes similitudes, las redes y el outsourcing no son cloud computing.


\subsection{Qu es cloud computing}

La clave de la definicin de Cloud Computing es el Cloud en s mismo. Para nuestro propsito, el cloud es un gran conjunto de ordenadores 
interconectados. Estos computadores pueden ser PC's o servidores, pblicos o privados. 

Esta nube de computadores se extiende ms all de una simple compa耥a o empresa. Las aplicaciones y datos servidos por la nube estn 
disponibles para un amplio grupo de usuarios, a travs de empresas y plataformas. El acceso es va Internet. Cualquier usuario autorizado 
puede acceder a estos documentos  y aplicaciones  desde cualquier ordenador con conexin a Internet. Y, para el usuario, la tecnologa e 
infraestructura que se esconde detrs de la nube es invisible. 


Para ejemplificar algunos de los puntos ms interesantes del cloud computing nos basaremos en
Google, una de las principales compa耥as impulsoras del Cloud. Segn su perspectiva, hay seis
propiedades clave en el cloud computing.

\begin{itemize}

% no uses expresiones inglesas cuando hay una espa帽ola perfectamente
% v谩lida. - JJ - FERGU: cambiado
\item Es ``Centrado en el usuario'': Una vez que t eres un usuario conectado a la nube, cualquier cosa que haya almacenada all - documentos, mensajes, 
imgenes, aplicaciones - se convierte en tuya. Adems, no solo los datos son tuyos sino que puedes compartirlos con otros. 
En efecto, cualquier dispositivo que acceda a tus datos en la nube tambin convierte los datos en suyos.
\item Es ``Centrado en la tarea'': En vez de concentrarse en la aplicacin y qu hacer, se centra en lo que necesitas y cmo la aplicacin puede 
hacerlo por ti. Las aplicaciones tradicionales - procesadores de textos, hojas de clculo, email... -  se estn convirtiendo en ms 
importantes que los documentos que se crean.
\item Es poderoso: Conectando cientos o miles de computadores juntos en una nube se crea una riqueza de computacin imposible de hacer 
en un nico PC.
\item Es accesible: Como los datos son almacenados en la nube, usuarios pueden recuperar informacin instantneamente desde mltiples 
repositorios. No ests limitado a una nica fuente de datos, como lo ests en un PC.
\item Es inteligente: Con el volumen de datos almacenados en la nube, el data-mining y anlisis son necesarios para acceder a esta 
informacin de una manera inteligente.
\item Es programable: Muchas de las tareas necesarias para el cloud computing deben de ser automatizadas. Por ejemplo, para proteger 
la identidad de los datos, la informacin almacenada en un nico computador en la nube debe ser replicada en los otros computadores 
de la nube. Si uno de stos falla, la programacin de la nube redistribuir automticamente los datos de ste computador hacia uno 
nuevo de la nube.

\end{itemize}

\section{Amazon Web Services}
\label{sec:aws}
En esta seccin se presenta {\it Amazon Web Services} 
\cite{Eva11} en general, y en particular, los servicios que se han
utilizado para el desarrollo de 
este trabajo.


\subsection{Caractersticas}

Amazon EC2 proporciona un servicio Web que permite obtener y configurar recursos computacionales de
forma sencilla. Proporciona un control completo de los recursos computacionales y permite al usuario
emplear el entorno de Amazon.
Amazon EC2 reduce el tiempo requerido para obtener e iniciar nuevas instancias a minutos, permitiendo escalar la capacidad de 
forma rpida y en funcin de los requerimientos. Amazon EC2 permite al usuario adquirir la capacidad que en cada momento necesita. 
Adems, proporciona a los desarrolladores las herramientas para construir aplicaciones robustas y aislarlas de los escenarios comunes 
propensos a fallos.

Amazon EC2 es un entorno de computacin virtual que permite emplear interfaces Web para lanzar
instancias de una gran variedad de 
sistemas operativos, instalar entornos de aplicaciones personalizados, gestionar los permisos de acceso a
la red, y ejecutar las imgenes virtuales usando tantos sistemas como sea preciso.

Para emplear Amazon EC2 es necesario:

\begin{itemize}
 \item Seleccionar una plantilla preconfigurada para ser ejecutada de forma inmediata, o crear una Amazon Machine Image (AMI) 
 que contenga sus aplicaciones, libreras, datos y las opciones de configuracin asociadas.
 \item Configurar la seguridad y el acceso a la red para la instancia de Amazon EC2.
 \item Escoger el tipo de instancia y el sistema operativo que desee y, a continuacin, iniciar, apagar y monitorizar tantas 
 instancias como sea necesario, usando las APIs del servicio Web o la gran variedad de herramientas proporcionadas.
 \item Determinar si se ejecutarn las mquinas virtuales en mltiples ubicaciones, si se utilizarn direcciones IP estticas o se 
 conectarn sistemas de almacenamiento persistente a las mismas.
 \item Pagar slo por los recursos que se consumen, como el de tiempo de CPU de las instancias o los datos transferidos.
 
\end{itemize}

\subsection{Aspectos destacados del servicio}

\begin{itemize}
 \item \textbf{Elstico}. Amazon EC2 permite incrementar o reducir la capacidad en minutos. Se podra ordenar la iniciacin de 
 cientos o miles de instancias de mquinas virtuales de forma simultnea. La aplicacin de usuario podra escalar de forma automtica 
 los recursos necesarios en funcin de las necesidades de la aplicacin empleando el API del servicio Web de Amazon.
 \item \textbf{Controlado por completo}. Se tiene el control completo de las instancias. El usuario tiene acceso de root a cada una
 de ellas y, por tanto, podra controlarlas de la misma forma que cualquier otra mquina.
 \item \textbf{Flexible}. Permite seleccionar distintos tipos de instancias, sistemas operativos y paquetes de software. Amazon EC2 
 permite seleccionar la configuracin de memoria, CPU, espacio de almacenamiento, tamao de la particin de inicio. 
 \item \textbf{Diseado para ser empleado con otros servicios Web de Amazon}. Amazon EC2 emplea el servicio de almacenamiento 
 Amazon Simple Storage Service (Amazon S3), Amazon SimpleDB y Amazon Simple Queue Service (Amazon SQS) para proporcionar una solucin 
 completa a la computacin, el procesamiento de colas y el almacenamiento en un amplio rango de aplicaciones.
 \item \textbf{Confiable}. Amazon EC2 ofrece un entorno confiable donde puedan reemplazarse las instancias de forma rpida y 
 predecible. El acuerdo de nivel de servicio de Amazon es del $99.95\%$ para cada una de las zonas
de la regin de Amazon EC2.
 \item \textbf{Seguro}. Amazon EC2 proporciona numerosos mecanismos de seguridad para los recursos. Incluye interfaces Web para 
 configurar las opciones de firewall entre sus grupos de instancias.
 \item \textbf{Barato}. Se cobra una tasa reducida por la capacidad de computacin que se consume. Existen diferentes 
 servicios:
  \subitem \textit{Instancias bajo demanda}. Permiten pagar por la capacidad de computacin por cada hora de utilizacin sin la necesidad 
  de establecer compromisos a largo plazo. Esto permite liberar al usuario de los costes y la complejidad que supone la planificacin, 
  la adquisicin y el mantenimiento de hardware.
  \subitem \textit{Instancias reservadas}. Las instancias reservadas permiten efectuar un pago inicial bajo, de usa sola vez para 
  cada instancia que desea reservar y disponer de una tasa de descuento significativo en la utilizacin por hora de la misma.
  \subitem \textit{Instancias Spot}. Permiten al usuario efectuar una oferta por la capacidad no utilizada de Amazon EC2, lo que 
  permitira ejecutar las instancias durante el tiempo que el precio ofertado supere al precio actual de los recursos no utilizados.

\end{itemize}




\section{Modelo MapReduce}
\label{sec:mapreduce}

Durante aos, los programadores se han visto forzados a realizar implementaciones especficas para trabajar con grandes 
volmenes de datos en sus entornos distribuidos de trabajo.

Pese a que no siempre es necesario, el tamao de la informacin entrante suele ser grande y los clculos deben ser distribuidos 
entre una gran multitud de mquinas para acabar en un tiempo razonable. Los problemas de cmo paralelizar estos clculos, 
distribuir la informacin y manejar los fallos dificultan basatante la labor de implementacin. 

El modelo de programacin MapReduce es una propuesta que pretende resolver las dificultades anteriores, ya que sus caractersticas 
y motivacin se basan en la delegacin de los cmputos intensivos en datos a un clster de mquinas remotas que,
mediante un sistema de ficheros distribuido, repartirn la carga de trabajo, optimizando tiempo y recursos. 
Asimismo, facilita un patrn de desarrollo paralelo para simplificar la implementacin de aplicaciones intensivas en 
datos en entornos distribuidos. Este modelo puede dividir un espacio grande de problema en espacios pequeos y paralelizar 
la ejecucin de tareas ms pequeas en estos sub-espacios. 

Este modelo ha cobrado especial inters por su aplicabilidad en entornos de Cloud Computing \cite{Web08}. 
MapReduce ofrece unas ventajas muy directas y evidentes como es la centralizacin de los datos en servidores remotos, 
eliminando las dependencias con los soportes fsicos; o la contratacin de servicios en funcin de las
necesidades de las empresas, sin tener que aadir equipos, software o personal, lo que conlleva un considerable ahorro 
tambin en el plano energtico. 


MapReduce \cite{Dea08} es un modelo de programacin, desarrollado por Google, que es utilizado para procesar grandes conjuntos de 
datos distribuidos a lo largo de un clster de servidores. Este procesado computacional puede tener lugar tanto sobre datos
almacenados en sistemas de ficheros, como en bases de datos. El modelo de programacin est inspirado en los lenguajes funcionales 
y permite al desarrollador expresar sus algoritmos utilizando nicamente dos funciones, \textbf{map} y \textbf{reduce}. 

Las funciones map y reduce de MapReduce se definen sobre datos estructurados en pares clave-valor. La funcin map, escrita por el 
usuario, recibe un par clave-valor y devuelve un conjunto de pares clave-valor intermedio:

\begin{equation}
	map: (k1 , v1) \xrightarrow{} [(k2 , v2)] 
  \label{EcuacionMap}
\end{equation}


Esta funcin (\ref{EcuacionMap})  se aplica en paralelo a cada par del conjunto de datos de entrada produciendo una lista de 
pares $(k2, v2)$ por cada llamada. MapReduce agrupa todos los valores intermedios asociados con la misma clave k y se los 
pasa a la funcin reduce.

La funcin reduce (\ref{EcuacionReduce}) recibe dicha clave y su conjunto de valores asociados y los fusiona para formar un conjunto 
de valores ms pequeo:


\begin{equation}
	reduce: (k2 , [v2]) \xrightarrow{} [v3]
	\label{EcuacionReduce}
\end{equation}


Cada llamada reduce produce bien una lista v3 o un valor vaco. Los resultados de las llamadas se recopilan en la lista de 
resultados buscada. 




Desde la perspectiva del flujo de datos, la ejecucin de MapReduce consiste en M tareas map y R tareas reduce independientes. 
Generalmente, los resultados intermedios se particionan en R trozos para R tareas reduce. 



Los principales elementos de un flujo de trabajo MapReduce son los siguientes:

\begin{itemize}
 \item \textbf{Proceso que lee la entrada}: divide los datos de entrada en bloques, siendo asignados cada uno de estos bloques a la 
 funcin map correspondiente. Estos datos sern ledos de un almacenamiento estable y generar pares clave/valor. 
 Un ejemplo comn sera la lectura de un directorio entero, y la devolucin de un registro por cada lnea de cada fichero.

 \item \textbf{Funcin de mapeo} (map): Cada funcin map recibe una serie de pares clave-valor, los procesa individualmente, y 
 devuelve cero o ms pares clave-valor de salida. Los tipos de datos de la entrada y la salida de la funcin map suele ser
distintos. Por ejemplo, si la aplicacin realizase un conteo de palabras, la funcin map separara la lnea en palabras y 
sacara como resultado la palabra como clave y un 1 como valor.
 
 \item \textbf{Funcin de particin}: Las salidas de cada uno de los nodos map son asignadas a un nodo reduce en concreto a 
 partir del resultado obtenido por la funcin ``partition'' de la aplicacin. Esta funcin devuelve el ndice del reduce buscado, 
 dada una clave y un nmero de nodo reduce. Una funcin tpica es hallar el valor hash de la clave y hacer mdulo del nmero 
 de nodo reduce.

 \item \textbf{Funcin de comparacin}: La entrada de cada reduce se obtiene de la mquina en la que se ejecut y orden el 
 map utilizando la funcin de comparacin de la aplicacin.

 \item \textbf{Funcin de escritura de salida}: Escribe la salida de la funcin reduce en un almacenamiento estable, tpicamente 
 un sistema de ficheros distribuido.
 
\end{itemize}

El principal beneficio de este modelo de programacin es la simplicidad. El programador simplemente proporciona una descripcin 
del algoritmo centrada en su funcionalidad.



\section{Algoritmos Genticos}
\label{sec:ags}

La tcnica de bsqueda conocida como Algoritmo Gentico se basa en los mecanismos de seleccin que utiliza la naturaleza, 
de acuerdo a los cuales los individuos ms aptos de una poblacin son los que sobreviven, al adaptarse ms
fcilmente a los cambios que se producen en su entorno. Hoy en da se sabe que estos cambios se efectan en los genes de 
un individuo (unidad bsica de codificacin de cada uno de los atributos de un ser vivo), 
y que sus atributos ms deseables (es decir, los quele permiten adaptarse mejor a su entorno) se transmiten a sus descendientes 
cuando ste se reproduce sexualmente. 

La primera mencin del trmino Algoritmo Gentico, y la primera publicacin
sobre una aplicacin del mismo, se deben a J.D.Bagley \cite{Bagley67}, que dise耋 AGs para
buscar conjuntos de parmetros en funciones de evaluacin de juegos. 
Pero es otro cientfico el considerado creador de los AGs: John Holland, que los desarroll, junto a sus alumnos y colegas, 
durante los 60 y 70.  

El propsito original de Holland no era disear algoritmos para resolver problemas concretos, sino estudiar, de un modo formal, 
el fenmeno de la adaptacin tal y como ocurre en la naturaleza y desarrollar vas de extrapolar esos mecanismos de adaptacin
natural a los sistemas computacionales.  

En \cite{Holland75} Holland presentaba el AG como una
abstraccin de la evolucin biolgica, y proporcionaba el entramado terico para la adaptacin bajo el algoritmo gentico. 
El AG de Holland era un mtodo para desplazarse, de una poblacin de cromosomas a una nueva poblacin, utilizando
un sistema similar a la seleccin natural junto con los operadores de cruce, mutacin e inversin inspirados en la gentica. 
En este primitivo algoritmo, cada cromosoma consta de genes (bits) y cada uno de ellos es una muestra de un alelo particular (0  1). 
El operador de seleccin escoge entre los cromosomas de la poblacin aquellos con capacidad de reproduccin, y entre stos, 
los que sean ms compatibles producirn ms descendencia que el resto. El operador de cruce extrae partes de dos cromosomas,
imitando la combinacin biolgica de dos cromosomas aislados (gametos). Y por ltimo, el operador de mutacin se encarga de cambiar, 
de modo aleatorio, los valores del alelo en algunas localizaciones del cromosoma. 






\subsection{Algoritmo Gentico Bsico}

En esta seccin se describen los componentes de un algoritmo gentico bsico y sus formas ms comunes.

\subsubsection{Representacin de los Individuos}

Desde los primeros estudios de los AGs los individuos son cadenas binarias, siendo hoy en da an la aproximacin
ms utilizada, aunque existen otras que utilizan letras o valores nmericos para representar a sus cromosomas. 



La sencillez de la representacin binaria que utilizan los AGs les aporta caractersticas muy importantes de eficiencia. 
Sin embargo debemos disponer de un mtodo para poder evaluar la adecuacin del individuo como solucin al 
problema. Lgicamente, el mtodo de transformacin es especfico del problema considerado. Sin embargo, a la hora de disear
el mtodo de codificacin es importante tener en cuenta una serie de directrices. As, debemos buscar una codificacin tal que
cada punto del espacio de bsqueda est representado por el mismo nmero de cadenas binarias, y tal que sea capaz de representar
todos los puntos del espacio del problema. 

En el contexto de los AGs, el trmino cromosoma se refiere a un candidato a solucin del problema, que frecuentemente es 
codificado como una cadena de bits. Los genes son tanto un bit como bloques cortos de bits adyacentes 
que codifican un elemento particular del candidato a solucin. Un alelo en una cadena de bits ser 
un 0 o un 1 (para alfabetos largos cada posicin puede tener ms alelos). El genotipo de un individuo en un AG que emplea
cadenas de bits es, simplemente, la configuracin de bits del cromosoma de ese individuo. 

Cabe resaltar que en este trabajo se us tanto codificacin binaria como codificacin real que
consiste en exactamente lo mismo pero un gen es representado como un nmero real, generalmente en un dominio dado por el 
problema. 


\subsubsection{Funcionamiento}

Sea X el problema a resolver, el esquema general de un algoritmo gentico es el siguiente \cite{Her03}:




A continuacin se proceder a una explicacin exhaustiva de dicho algoritmo.
Dada una representacin de candidatos a soluciones en una cadena de bits, un AG simple, tal y como 
se describe en \cite{Mit98}, funcionara del siguiente modo:

\begin{enumerate}
 \item Comenzar con una poblacin P generada aleatoriamente de n cromosomas de L bits.
 \item Calcular el valor de la funcin de evaluacin o fitness (f(x)) para cada cromosoma x de P.
 \item Repetir los siguientes pasos hasta que se hayan creado todos los  descendientes:
 \begin{enumerate}
    \item Seleccionar un par de cromosomas de P, siendo la probabilidad de seleccin proporcional al fitness.
    Los cromosomas seleccionados sern llamados cromosomas padre.
    \item Con probabilidad \textit{$p_c$} (tasa de cruce), cruzar el par de cromosomas padre en un punto (o ms)
    elegido aleatoriamente para formar dos descendientes. Si no tiene lugar ningn cruce, formar dos descendientes que sean copias
    exactas de sus respectivos padres.
    \item Mutar los dos descendientes en cada lugar con probabilidad \textit{$p_m$} (tasa de mutacin), y colocar 
    los cromosomas resultantes en la nueva poblacin P'.
 \end{enumerate}
 \item Reemplazar la poblacin actual P con la nueva poblacin P'.
 \item Evaluar la condicin de finalizacin.
 \item Volver al paso 2.

\end{enumerate}

En el paso 2 del algoritmo se habla de una funcin de evaluacin, la cual debe ser diseada para cada problema de manera 
especfica. Dado un cromosoma cualquiera, la funcin de evaluacin le asigna un nmero real, que se supone refleja el nivel de 
adaptacin al problema del  individuo representado por el cromosoma. 

Asimismo, la primera operacin del paso 3 del algoritmo es la llamada fase de seleccin. Esta seleccin se efecta usando 
un procedimiento que favorezca a los individuos mejor adaptados. Existen diferentes mtodos de seleccin, que posteriormente
veremos. 

Cada iteracin de este proceso recibe el nombre de generacin.
Cada generacin se obtiene a partir de la anterior por medio de los llamados operadores de reproduccin (paso 3 del algoritmo), 
que pueden ser de dos tipos:

\begin{enumerate}
 \item \textbf{Copia:} Es un tipo de reproduccin asexual, en la que un determinado nmero de individuos pasa directamente a la 
 siguiente generacin, sin sufrir ningn proceso de variacin en sus genes.
 \item \textbf{Cruce:} Es una reproduccin de tipo sexual en la que se genera una descendencia a partir de un nmero fijo de 
 individuos, dos por lo general, de la generacin anterior. Existen varios tipos de cruce, que veremos ms tarde.
\end{enumerate}


El algoritmo acabar cuando se cumpla la condicin de fin, que normalmente ser una de las siguientes:

\begin{enumerate}
 \item Se ha encontrado una solucin que satisface un criterio mnimo.
 \item Se ha llegado a un nmero determinado de generaciones establecido previamente.
 \item Se ha llegado a un lmite preestablecido en tiempo de computacin.
 \item Tras varias generaciones el fitness de la mejor solucin no ha variado.
 \item Parada manual.
 \item Combinacin de las anteriores
\end{enumerate}

Posiblemente el criterio ms utilizado sea el primero, segn el cual De Jong en su tesis doctoral
\cite{John75} afirm que si el AG es correcto, la poblacin evolucionar a lo largo de las sucesivas generaciones de tal forma que la
evaluacin media entre todos los individuos, as como la propia del mejor individuo, convergern hacia el ptimo global. 
Se dice que un gen ha convergido cuando al menos el 95\% de los individuos de la poblacin comparten el mismo valor para dicho gen. 
Se dice que la poblacin converge cuando todos los genes han convergido. Se puede generalizar dicha definicin al caso en que al menos un
$\beta \%$ de los individuos de la poblacin hayan convergido. 

El esqueleto de este algoritmo es la base de la mayora de las aplicaciones de los algoritmos genticos. Se podra profundizar mucho ms 
en detalles sobre cuales deben ser las diferentes probabilidades, tamao de la poblacin y nmero de generaciones. De esos detalles 
depender, en gran parte, el xito o fracaso de nuestro algoritmo.


% 驴No hay un estado del arte? Hay un art铆culo de Una-May O'Reilly en
% el 煤ltimo EvoStar sobre el tema - JJ
\section{Experimentos}
\label{sec:experimentos}
Esta seccin muestra los experimentos a realizar para hacer comparativas sobre la mejor configuracin para AGs en Amazon EC2.

\subsection{Parmetros de los algoritmos}

Se van a usar diferentes configuraciones para ver el comportamiento y tiempo de ejecucin en los distintos entornos. 
Primero se explicar lo que significa cada columna de las tablas y a continuacin se mostrarn.

\begin{itemize}
 \item \textbf{Funcin}: Funcin a optimizar, ya sea maximizar o minimizar.
 \item \textbf{Poblacin}: Tamao de la poblacin de individuos.
 \item \textbf{Individuo}: Longitud de cada individuo en bits.
 \item \textbf{Generaciones}: Nmero de generaciones que queremos evaluar.
 \item \textbf{Mutrate}: Tasa de mutacin en \%.
 \item \textbf{Crossrate}: Tasa de cruce en \%.
 \item \textbf{Selrate}: Tasa de seleccin en \%.
 \item \textbf{Seleccin}: Mtodo de seleccin.
 \item \textbf{Cruce}: Mtodo de cruce.
 \item \textbf{Mutacin}: Mtodo de mutacin.
 \item \textbf{Reemplazamiento}: Mtodo de reemplazamiento.
\end{itemize}

Todos los parmetros y configuraciones se han establecido buscando la mayor variedad posible con el objeto de tener diferentes 
opiniones sobre la ventajas e inconvenientes en  escalabilidad, tiempo de ejecucin...

\begin{table}[htb]

  \begin{tabular}{|| c | c | c | c |c | c | c ||}
    \hline
    \textbf{Configuracin} & \textbf{Poblacin} & \textbf{Bits} & \textbf{Generaciones} &
    \textbf{Selrate} & \textbf{Crossrate} & \textbf{Mutrate}  \\

    \hline
    \textbf{Config.1} & 10000 & 512 & 100 & 30 & 10 & 10 \\
    \hline
    \textbf{Config.2} & 30000 & 512 & 200 & 20 & 20 & 20 \\
    \hline
    \textbf{Config.3} & 50000 & 512 & 500 & 40 & 30 & 10 \\
    \hline
  \end{tabular}
  \caption{Rastrigin. Tabla de configuraciones establecidas.} 
  \label{TablaParametrosRastrigin}
\end{table}


\begin{table}[htb]
  \begin{tabular}{|| c | c | c | c | c ||}
    \hline
    \textbf{Configuracin} & \textbf{Seleccin} & \textbf{Cruce} & \textbf{Mutacin} & \textbf{Reemplazamiento} \\
    \hline
    \textbf{Config.1} & Probabilistic (10\%) & One-Point & NRandom (1) & Worst \\
    \hline
     \textbf{Config.2} & Deterministic & Two-Point & NRandom (1) & Worst  \\
    \hline
    \textbf{Config.3} & Probabilistic (10\%) & One-Point & NRandom (1) & Worst  \\
    \hline
  \end{tabular}
  \caption{Rastrigin. Metodos de seleccin, cruce, mutacin y reemplazamiento.} 
  \label{TablaMetodosRastrigin}
\end{table}

\begin{table}[htb]

  \begin{tabular}{|| c | c | c | c |c | c | c ||}
    \hline
    \textbf{Configuracin} & \textbf{Poblacin} & \textbf{Individuo} & \textbf{Generaciones} &
    \textbf{Selrate} & \textbf{Crossrate} & \textbf{Mutrate}  \\

    \hline
    \textbf{Config.1} & 2500 & 64 & 800 & 40 & 15 & 10 \\
    \hline
    \textbf{Config.2} & 10000 & 64 & 1000 & 20 & 30 & 10 \\
    \hline
    \textbf{Config.3} & 50000 & 64 & 2000 & 40 & 15 & 10 \\
    \hline
  \end{tabular}
  \caption{Marea. Tabla de configuraciones establecidas.} 
  \label{TablaParametrosMarea}
\end{table}

\begin{table}[htb]
  \begin{tabular}{|| c | c | c | c | c ||}
    \hline
    \textbf{Configuracin} & \textbf{Seleccin} & \textbf{Cruce} & \textbf{Mutacin} & \textbf{Reemplazamiento} \\
    \hline
    \textbf{Config.1} & Probabilistic (15\%) & Two-Point & NRandom (1) & Generational \\
    \hline
     \textbf{Config.2} & Deterministic & One-Point & NRandom (2) & Worst  \\
    \hline
    \textbf{Config.3} & Probabilistic (15\%) & Two-Point & NRandom (1) & Generational  \\
    \hline
  \end{tabular}
  \caption{Marea. Metodos de seleccin, cruce, mutacin y reemplazamiento.} 
  \label{TablaMetodosMarea}
\end{table}


\begin{table}[htb]

  \begin{tabular}{|| c | c | c | c |c | c | c ||}
    \hline
    \textbf{Configuracin} & \textbf{Poblacin} & \textbf{Individuo} & \textbf{Generaciones} &
    \textbf{Selrate} & \textbf{Crossrate} & \textbf{Mutrate}  \\

    \hline
    \textbf{Config.1} & 10000 & 512 & 1000 & 30 & 30 & 10 \\
    \hline
    \textbf{Config.2} & 20000 & 512 & 3000 & 50 & 30 & 20 \\
    \hline
    \textbf{Config.3} & 40000 & 512 & 3000 & 50 & 30 & 10 \\
    \hline
  \end{tabular}
  \caption{OneMax. Tabla de configuraciones establecidas.} 
  \label{TablaParametrosOneMax}
\end{table}

\begin{table}[htb]
  \begin{tabular}{|| c | c | c | c | c ||}
    \hline
    \textbf{Configuracin} & \textbf{Seleccin} & \textbf{Cruce} & \textbf{Mutacin} & \textbf{Reemplazamiento} \\
    \hline
    \textbf{Config.1} & Deterministic & Two-Point & NRandom (1) & Worst \\
    \hline
     \textbf{Config.2} & Probabilistic (15\%)  & One-Point & NRandom (2) & Generational \\
    \hline
    \textbf{Config.3} & Probabilistic (15\%) & One-Point & NRandom (1) & Worst  \\
    \hline
  \end{tabular}
  \caption{OneMax. Metodos de seleccin, cruce, mutacin y reemplazamiento.} 
  \label{TablaMetodosOneMax}
\end{table}

\subsubsection{Entorno Local}

La solucin secuencial fue probada en una mquina aislada, que corra Ubuntu 12.04 de 64 bits. El equipo en cuestin es un 
HP Pavilion DV6 3034ss, Intel(R) Core(TM) i5 CPU M 450 @ 2.40GHz, 4 GB RAM.

\subsubsection{Entorno Cloud de Amazon}

La batera de ejecuciones en la nube de Amazon consta de diferentes mquinas virtuales, instancias con diferentes caractersticas 
cada una:

\begin{itemize}
 \item \textbf{Micro}: 613 MB de memoria, un mximo de dos unidades informticas EC2 (para rfagas peridicas cortas) y nicamente  
 almacenamiento EBS. Plataforma de 32 o 64 bits.
 \item \textbf{Small}: Dispone de 1.7 GB de memoria, una unidad de computacin EC2 (1 ncleo virtual con una unidad informtica EC2), 
 160 GB de almacenamiento, plataforma de 32 o 64 bits.
 \item \textbf{Medium}: Dispone de 3.75 GB de memoria, dos unidades de computacin EC2 (1 ncleo virtual con dos unidades 
 informticas EC2), 410 GB de almacenamiento, plataforma de 32 o 64 bits.
 \item \textbf{Large}: Dispone de 7.5 GB de memoria, cuatro unidades de computacin EC2 (2 ncleos virtuales con dos unidades 
 informticas cada uno de ellos), 850 GB de almacenamiento, plataforma de 64 bits.
 \item \textbf{ExtraLarge}: Dispone de 15 GB de memoria, ocho unidades de computacin EC2 (4 cores virtuales con dos unidades 
 informticas cada uno de ellos), 1690 GB de almacenamiento, plataforma de 64 bits.
 \item \textbf{High-CPU ExtraLarge}:  7 GB de memoria, 20 unidades informticas EC2 (8 ncleos virtuales 
 con 2,5 unidades informticas EC2 cada uno), 1.690 GB de almacenamiento de instancias, plataforma de 64 bits.
\end{itemize}


Los resultados de todas las ejecuciones para cada tipo de instancia, pueden consultarse en la direccin 
\url{https://s3.amazonaws.com/secuencial/results/$<$Problema$>$ $<$Configuracin$>$.txt}

siendo $<$Problema$>$ el problema que se desea consultar y $<$Configuracin$>$ el nmero de configuracin. As, por ejemplo, si se desea consultar los resultados del problema ``Marea'' con 
la configuracin 2, habra que descargar el fichero desde: 
\url{https://s3.amazonaws.com/secuencial/results/Marea2.txt}

Veamos, primero, las tablas de resultados de tiempo de ejecucin, para cada problema y tanto en entorno local, como en 
entorno Cloud, en cada tipo de instancia. Podemos apreciarlos en las tablas 

\begin{table}[htb]
\begin{tabular}{|| c | c | c | c | c |c | c | c ||}
    \hline
    \textbf{Configuracin} & \textbf{Local} & \textbf{Micro} & \textbf{Small} & \textbf{Medium} &
    \textbf{Large} & \textbf{ExtraLarge} & \textbf{High CPU EL}  \\

    \hline
    \textbf{Config. 1} & 62 & 225 & 117 & 62 & 72 & 58 & 54 \\
    \hline
    \textbf{Config. 2} & 354 & Error & 703 & 373 & 424 & 338 & 320 \\
    \hline
    \textbf{Config. 3} & 1972 & Error & Error & 1583 & 1807 & 1434 & 1357 \\
    \hline
  \end{tabular}
  \caption{Tiempo de Ejecucin en segundos. Rastrigin.} 
  \label{TablaParametrosRastrigin}
\end{table}


\begin{table}[htb]
\begin{tabular}{|| c | c | c | c | c |c | c | c ||}
    \hline
    \textbf{Configuracin} & \textbf{Local} & \textbf{Micro} & \textbf{Small} & \textbf{Medium} &
    \textbf{Large} & \textbf{ExtraLarge} & \textbf{High CPU EL}  \\

    \hline
    \textbf{Config. 1} & 16 & 47 & 41 & 21 & 24 & 19 & 17 \\
    \hline
    \textbf{Config. 2} & 164 & 701 & 425 & 222 & 253 & 203 & 169 \\
    \hline
    \textbf{Config. 3} & 815 & 4067 & 2070 & 1070 & 1215 & 974 & 818 \\
    \hline
  \end{tabular}
  \caption{Tiempo de Ejecucin en segundos. Marea.} 
  \label{TablaParametrosMarea}
\end{table}


\begin{table}[htb]
\begin{tabular}{|| c | c | c | c | c |c | c | c ||}
    \hline
    \textbf{Configuracin} & \textbf{Local} & \textbf{Micro} & \textbf{Small} & \textbf{Medium} &
    \textbf{Large} & \textbf{ExtraLarge} & \textbf{High CPU EL}  \\

    \hline
    \textbf{Config. 1} & 99 & 583 & 220 & 111 & 134 & 108 & 106 \\
    \hline
    \textbf{Config. 2} & 664 & 4043 & 1280 & 715 & 797 & 634 & 669 \\
    \hline
    \textbf{Config. 3} & 1648 & Error & 3029 & 1667 & 1936 & 1527 & 1578 \\
    \hline
  \end{tabular}
  \caption{Tiempo de Ejecucin en segundos. OneMax} 
  \label{TablaParametrosOneMax}
\end{table}

La convergencia de los algoritmos puede ser vista en los ficheros de resultados antes nombrados. No obstante, vamos a estudiar 
algn caso para verla grficamente.



%\begin{figure}[h]
%  \begin{center}
%  \includegraphics[scale=0.7]{figuras/graficos/tiempo.jpg}
%  \caption {Comparativa de tiempos. Config: Marea3.xml} 
%  \label{FiguraTiempos}
% \end{center}
%\end{figure}	

Se puede observar que el portatil, el llamado entorno local, se ha comportado muy bien, puesto que tiene tiempos de manera similar a 
la instancia ExtraLarge y HCPUExtraLarge, por lo que en el caso de querer hacer pocas pruebas, quizs con el entorno local 
valdra, pero no es el caso, porque hemos hecho una batera relativamente grande de pruebas.  

Por otra parte, las instancias 
Small y Micro, quedaran totalmente descartadas para algn futuro proyecto, puesto que el tiempo excede de los lmites 
permitidos, sobre todo la micro instancia. Estas instancias, pueden ser vlidas en el Cloud Computing como servidor de pequeas 
webs o pruebas que no requieran de demasiado cmputo de datos. 

Pasemos ahora a estudiar la escalabilidad, que viendo los ficheros de resultados queda demostrada que existe, pero el objetivo es 
ver el comportamiento segn la configuracin y los mtodos escogidos. Se ha escogido como instancia representativa, los resultados 
de la instancia Large, puesto que los tiempos son relativamente buenos y no tiene problemas de algn resultado que no se tiene, 
por error en la memoria y similares.

Primero, observemos la Figura \ref{GraficaMarea}. Esta figura muestra la convergencia al ptimo, que sera 1, durante las 10 
primeras iteraciones. Hay que aclarar primero, que la aleatoriedad a la hora de generar la poblacin inicial juega un papel 
importante pero, aparte de esto, se pueden destacar varios puntos.

\begin{itemize}
 \item La configuracin 2 converge ms rpidamente. Esto obedece a que para problemas no demasiado complejos, el reemplazo 
 de los peores se comporta mejor que el reemplazo generacional.
 \item Las configuraciones 1 y 3 son iguales, excepto en el tamao de la poblacin y nmero generaciones. Esto no influye, 
 en la convergencia en las 10 primeras iteraciones y queda reflejado en la figura, que convergen de manera muy similar.
 \item Otro punto caracterstico de estas dos configuraciones es que la lnea de convergencia hay un punto en el que 
 baja en vez de ir en aumento en busca del ptimo. El porqu es muy 
 sencillo, la seleccin probabilstica hace que a veces el mejor sea descartado, que es lo que ha ocurrido en estos dos 
 casos.
\end{itemize}


\begin{figure}[h]
  \begin{center}
  \includegraphics[scale=0.7]{images/Marea.eps}
  \caption {Marea. Convergencia en instancia Large para las 3 configuraciones.} 
  \label{GraficaMarea}
 \end{center}
\end{figure}

Sin nada ms que referirnos, pasemos a observar una figura similar, pero correspondiente a la funcin Rastrigin. En este caso, 
no hace falta sealar que la convergencia hacia abajo se debe, a que es una funcin de minimizacin. En esta figura hay que destacar:

\begin{itemize}
 \item La configuracin 3 es la que se comporta mejor, de manera destacada en las 100 primeras iteraciones de Rastrigin. Por detrs 
 de ella ira la configuracin 2 y finalmente la uno parece que es la peor.
 \item En este caso podemos ver lo anteriormente comentado, parece que la mayor convergencia es fruto del azar y 
 la probabilidad, puesto que las configuraciones 1 y 3 son la misma, pero es bastante probable, que al generar 50 mil individuos 
 saldr unos mejores individuos que al generar 10 mil como ocurre en la configuracin nmero 1.
\end{itemize}


\begin{figure}[h]
  \begin{center}
  \includegraphics[scale=0.7]{images/Rastrigin.eps}
  \caption {Rastrigin. Convergencia en instancia Large para las 3 configuraciones.} 
  \label{GraficaRastrigin}
 \end{center}
\end{figure}


Por ltimo, la Figura \ref{GraficaOneMax}, muestra la convergencia durante 300 iteraciones de la funcin OneMax, que cuenta 
los unos de un cromosoma binario, hasta maximizar este nmero. El  ptimo sera 512, que es el tamao de la cadena elegido 
para observar los resultados.

\begin{figure}[h]
  \begin{center}
  \includegraphics[scale=0.7]{images/OneMax.eps}
  \caption {Rastrigin. Convergencia en instancia Large para las 3 configuraciones.} 
  \label{GraficaOneMax}
 \end{center}
\end{figure}

\begin{itemize}
 \item El mejor comportamiento es la configuracin 3. Parece que aqu influye de nuevo el nmero de individuos de la poblacin. 
 Llega al ptimo casi unas 20 iteraciones antes que sus competidores.
 \item El reemplazo generacional de la configuracin 2 vemos que en un inicio de algoritmo puede no ser muy bueno si no hay buena 
 calidad en la poblacin inicial, sin embargo observamos que la convergencia es constante, no como en el caso de la primera, que 
 tras un buen inicio, converge ms lentamente hasta ser la ltima en alcanzar el ptimo. Quizs el hecho de la menor presin 
 de seleccin haya influido en esto.
\end{itemize}






\section{Anlisis de los resultados}
\label{sec:analisis}
Una vez vistos los resultados, analizando las tablas de tiempos, ficheros de resultados y grficas obtenidas 
podemos sacar las siguientes conclusiones:

\begin{itemize}
 \item \textbf{Limitacin de Algunas instancias}. Algunas de las instancias, como era evidente no tienen memoria suficiente para realizar tareas complejas de clculos. En 
 nuestro caso, ha quedado demostrado en las instancias micro que no ha podido resolver Rastrigin con la configuracin 2 y 3, y 
 la small que no ha podido resolver la configuracin 3 del mismo problema, ambas por falta de memoria, debido a que el problema 
 Rastrigin trabaja con un gran nmero de nmeros reales de precisin doble lo que hace ocupar gran parte de la memoria disponible.
 \item \textbf{Beneficioso}. En los dems casos, la utilizacin del cloud computing ha sido favorable debido a que los tiempos que nos han dado 
 han sido muy parecidos, en muchos casos mejores, a los de nuestro pc, lo que lleva a pensar que para casos ms complejos 
 se podran comportar mejor.
 \item \textbf{Trabajo Paralelo en Instancias}. Otra ventaja ha sido, que, en el mismo tiempo que se han realizado las ejecuciones para nuestro entorno local, han sido 
 llevadas a cabo todas las ejecuciones en las seis instancias en la nube, ya que, las instancias han trabajado paralelamente y,
 lgicamente, sin influir unas con otras.
 \item \textbf{Seleccin}. Para el caso de la seleccin, en nuestro caso se ha comportado mejor la seleccin determinstica por torneo, puesto que 
 los problemas que hemos tratado no son muy complejos, se ha llegado al ptimo relativamente rpido y no han requerido de una 
 ampla bsqueda ni en la salida de grandes ptimos locales, que son en los casos en los que la probabilstica podra 
 resultar favorable. Podemos apreciar una cosa curiosa en la seleccin probabilstica, y es que cuando se ha alcanzado el ptimo, 
 y en todas las iteraciones sea este el mejor individuo, hay alguna iteracin en los que se genera uno peor a l y es seleccionado 
 como mejor, quedando una grfica y tanto rara.
 \item \textbf{Reemplazamiento}. El reemplazamiento generacional depende mucho de las tasas de seleccin, cruce y mutacin elegidas. 
 Si stas son bajas, la poblacin puede ir incluso decreciendo, pueso que la generacin anterior es entera borrada y 
 la nueva contendr menos individuos. Esto hace que su comportamiento sea ligeramente ms rpido en estos casos. Sin embargo, 
 en nuestro problema ha resultado mejor el reemplazamiento de los nuevos individuos generados por los menos adaptados de la 
 generacin anterior (Worst), quizs por la misma razn que antes en la seleccin, no son problemas suficientemente complejos 
 que requieran de una diversidad grande.
 \item \textbf{Cruce}. No se ha encontrado ningn resultado digno de mencionar en cuanto al cruce de uno o dos puntos. Por cuestiones 
 puramente tericas, podemos decir que el de dos puntos puede dar ms diversidad a la poblacin, pero no se ha visto que esto 
 quede plasmado en nuestro estudio.
 \item \textbf{Mejorable}. Para muchos exigentes, esto no es suficiente, necesitan mejoras de tiempos evidentes y por ello se 
 ha propuesto una alternativa mejor con Map Reduce.
\end{itemize}

\section{Conclusiones y trabajo futuro}
\label{sec:conc}




El Cloud Computing ha llegado con mucha fuerza y todo hace indicar que viene para quedarse.  Hemos visto durante, 
la primera parte que son muchas ms las ventajas que nos ofrece este modelo que los inconvenientes a los que nos podemos 
enfrentar.  

Todo proveedor de computacin en la nube, nos ofrece una infraestructura que, a no ser que estemos en una gran empresa o 
seamos poseedores de superordenadores, no est a nuestro alcance y ello nos hace que instantneamente podamos acceder 
a esos recursos y hacer uso de ellos de una forma rpida, sencilla y con un coste bajo.  Precisamente esta posibilidad hace que 
sea una tecnologa verdaderamente interesante para el mundo cientfico e investigador, pues habitualmente en tareas como 
anlisis financiero, meteorolgico o bioinformtica, entre otras muchas cosas, se trabaja con ingentes cantidades de datos 
que requieren de millones de clculos en poco tiempo y precisan de mucho tiempo, pese a tener grandes centros de datos. 

Por ello en este proyecto se ha propuesto un pequeo estudio dentro del gran mundo que es la bioinformtica, utilizando 
la infraestructura de Amazon, el mayor proveedor de Cloud Computing y mucho ms configurable que Google App Engine,
para la ejecucin y anlisis de algoritmos genticos bsicos.  

Se ha implementado una pequea librera para el diseo de algoritmos genticos de forma secuencial y un completo manual para 
la ejecucin de estos algoritmos en los servicios web de Amazon.  Las caractersticas ms importantes de esta propuesta han sido:

\begin{itemize}
 \item \textbf{Extensibilidad:} Desde el primer momento de desarrollo se ha pretendido dotar a la librera de un carcter extensible, 
 abstrayendo todo lo posible los distintos elementos dentro de un AG con el uso de interfaces, herencia y dems 
 ventajas de un lenguaje como Java y facilitando el prototipado rpido de AGs  mediante la implementacin de un nmero mnimo de 
 funciones.

 \item \textbf{Portabilidad}: La aplicacin se encapsula en un fichero JAR que puede ser ejecutado en cualquier entorno anfitrin que 
 disponga de un compilador Java, independientemente de su sistema operativo. Esto se ha hecho as, porque el objetivo principal e
 era ver las ventajas de computacin en la nube, y lo mejor era un sistema portable entre distintas instancias voltiles en 
 Amazon EC2.

 \item \textbf{Sencillez}: El objetivo principal del trabajo, era conocer un poco ms distintas posibilidades de servicios de la 
 nube de Amazon y como facilita el anlisis de datos  y no profundizar mucho en Algoritmos Genticos, por esta razn se han 
 implementado tres funciones sencillas. El nico conocimiento necesario para realizar las pruebas viene explicado detalladamente 
 en el documento adjunto o la documentacin generada por cada proyecto.
 
 \item \textbf{Aprendizaje}: Este trabajo es vlido tanto como para alguien quiera iniciarse en el conocimiento de los algoritmos 
 genticos, como para alguien que quiere sentar las bases de Cloud Computing tener acceso a instancias virtuales en Amazon.
 
\end{itemize}


Una vez vistos hecho el anlisis de los resultados de la versin secuencial surgi la posibilidad de buscar una alterantiva  
paralela para un algoritmo gentico  e investigando se encontr la posibilidad de  usar MapReduce, por ello, se ha descrito 
tericamente en que consiste este modelo y en concreto, la implementacin por parte de  Hadoop, que es la 
ms conocida. 


Para introducirnos en el mundo de Hadoop, se ha explicado como hacer una configuracin pseudo-distribuida en nuestro pc para 
comenzar a escribir aplicaciones de este tipo. Como primer ejemplo de ello, se ha propuesto y explicado la 
implementacin de un bsico contador de frecuencias de palabras en un conjunto de archivos, 
que pese a ser sencillo, nos da una muestra del potencial de MapReduce y de la sencillez de su implementacin.  


Como extensin se ha presentado una aproximacin a un sistema capaz de adaptar la naturaleza intensiva en datos del modelo MapReduce con el carcter 
iterativo de un Algoritmo Gentico, sentando las bases para construir un software que permita ejecutar de forma distribuida 
algoritmos genticos paralelos tanto sobre clsters, como sobre el servicio que nos proporciona Amazon Elastic MapReduce.  


En lneas generales, se ha descrito el diseo y la implementacin de AGs bsicos tanto de forma secuencial  como paralela utilizando 
entornos secuenciales y de cloud computing con Amazon como proveedor, y se ha introducido al uso del Framework de Hadoop para el 
diseo de aplicaciones con MapReduce.


Por ltimo, destacar que las pruebas realizadas con la batera de problemas elegida (``Rastrigin'', ``OneMAX'' y ``Marea'') arrojan 
resultados satisfactorios en cuanto a escalabilidad y tiempo, teniendo en cuenta adems que nuestra computadora desde la que 
mandamos los trabajos no consume recurso alguno. 


\section*{Futuras lneas de trabajo}


Hasta el momento solo ha podido desarrollarse un modelo de cmo sera la implementacin de un algoritmo gentico paralelo 
usando MapReduce.  La principal lnea de trabajo sera terminar la implementacin de este modelo y hacer extensible 
las clases implementadas para la parte secuencial a la parte paralela.

Dentro de la lnea seguida en el proyecto podemos contemplar otras alternativas que completaran el estudio del modelo de 
programacin MapReduce:

\begin{itemize}
 \item Se podra investigar si compensa la generacin inicial de individuos con una tarea MapReduce como propone \cite{Gen09}. 
Esto sera til para utilizar poblaciones de gran tamao ya que en este caso, tendra un costo inicial muy alto para el 
nodo maestro mientras los otros se encontraran ociosos.
 \item Otro aspecto que podra ser estudiado es la definicin de una clase personalizada InputFormat (la encargada de describir la 
especificacin de los datos de entrada de un trabajo MapReduce) para poder configurar el nmero de tareas map a gusto del usuario.
\end{itemize}

En lo que engloba al Cloud Computing, hay varias opciones que nos gustara llevar a cabo:

\begin{itemize}
 \item Mover una aplicacin a la nube, migrar sus datos, configurar una  instancia para que no sea voltil, contratando una ip esttica  y que 
 sta acte como servidor, y montar una pgina web en ella. 
 \item Utilizar proveedores PaaS, como Windows Azure o Google App Engine para desarrollar un servicio en la web. 
\end{itemize}


\bibliographystyle{splncs}
\bibliography{cloudproject}
\end{document}
