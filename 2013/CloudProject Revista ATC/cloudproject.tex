\documentclass[runningheads]{llncs}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
%%%%
\usepackage{color}
\usepackage{alltt}
\usepackage{verbatim}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
%%
\usepackage{url}
\urldef{\mailsa}\path|{pgarcia,pedro}@atc.ugr.es|

\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\begin{document}
 \pagestyle{empty} %ESTO QUITA LOS N√öMEROS DE P√ÅGINA
\mainmatter  % start of an individual contribution

% first the title is needed
\title{Estudio sobre algoritmos gen√©ticos en la nube y el modelo de programaci√≥n MapReduce\thanks{Financiado con los proyectos EvOrq (TIC-3903) y Beca FPU AP2009-2942. }}

% Mete tambiÈn el del ministerio, que estaba vigente cuando el PFC. 

% a short form should be given in case it is too long for the running head
\titlerunning{Estudio sobre AGs en la nube}

% the name(s) of the author(s) follow(s) next
%
% NB: Chinese authors should write their first names(s) in front of
% their surnames. This ensures that the names appear correctly in
% the running heads and the author index.
%
\author{G. Mu\~noz \inst{1} \and Pablo Garc\'ia-S\'anchez\inst{1}  \and Pedro A. Castillo\inst{1}  \and Quien sea \inst{1}}
%
\authorrunning{P. Garc\'ia-S\'anchez et al.}
% (feature abused for this document to repeat the title also on left hand pages)

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
\institute{Dept. de Arquitectura y Tecnolog√≠a de los Computadores, Universidad de Granada\\
\mailsa}


%
% NB: a more complex sample for affiliations and the mapping to the
% corresponding authors can be found in the file "llncs.dem"
% (search for the string "\mainmatter" where a contribution starts).
% "llncs.dem" accompanies the document class "llncs.cls".
%

\toctitle{Estudio sobre algoritmos gen√©ticos en la nube y el modelo de programaci√≥n MapReduce}
\tocauthor{Authors' Instructions}
\maketitle


\begin{abstract}
Este trabajo presenta el proyecto fin de carrera Estudio sobre algoritmos gen√©ticos en la nube y el modelo de progrmaci√≥n MapReduce.

\end{abstract}


\section{Introducci√≥n}
\noindent En la √∫ltima d√©cada Internet ha transformado nuestra econom√≠a y nuestra sociedad. Ha demostrado ser una infraestructura de comunicaci√≥n 
y enlace de gran valor que se adapta gradualmente a las necesidades de los usuarios. Con Internet se ha creado una red mundial de 
intercambio de conocimientos, creatividad y colaboraci√≥n. 

Del mismo modo, Internet ha dado un gran salto adelante gracias al despliegue de la banda ancha de muy alta velocidad, lo que ha 
permitido el lanzamiento de muchos nuevos servicios interactivos y de contenido. 

Todo esto hace que los programas inform√°ticos ofertados en la red como un servicio disminuyan sus costes y aumenten su eficacia, 
provocando una gran mejora de la productividad. Desplegado adecuadamente, el llamado Internet del futuro, que cada vez es m√°s 
presente, trae consigo innovaci√≥n, aumento de la productividad, nuevos mercados y m√°s crecimiento y empleo en esta d√©cada que 
reci√©n acabamos de comenzar. 

En este marco se engloba el Cloud Computing, un nuevo modelo de negocio en Internet, que beneficia tanto al proveedor de 
servicios en la nube como al usuario, capaz de tener acceso instant√°neo a una infraestructura barata, escalable y f√°cilmente 
accesible. 
 
Paralelamente a esta transformaci√≥n, la ciencia ha estado evolucionando constantemente durante los √∫ltimos lustros, en gran parte, 
gracias al uso  de la tecnolog√≠a. La investigaci√≥n cient√≠fica avanza al un√≠sono con √©sta, pues un cambio tecnol√≥gico, la mayor√≠a 
de las veces, abre un nuevo abanico de posibilidades para la comunidad cient√≠fica, puesto que, independientemente de que se trate 
de investigaci√≥n y desarrollo en un √°mbito cl√≠nico, cient√≠fico o industrial, existen m√∫ltiples par√°metros, como el uso intensivo 
de tecnolog√≠as y procesamiento de datos, que son comunes e independientes del sector en el que se desarrollen. 

Dentro de la investigaci√≥n existe adem√°s en los √∫ltimos tiempos un crecimiento exponencial del volumen de datos necesario para 
resolver los cada vez m√°s complejos problemas presentes en el d√≠a a d√≠a de un cient√≠fico o investigador. Dentro de estos conjuntos 
de problemas se encuentran los de b√∫squeda, a menudo representados por medio de Algoritmos Gen√©ticos, que se usan cada vez m√°s en 
escenarios de gran complejidad. 


Sentando estos principios evidentes en la sociedad actual, el motivo de este trabajo es el de buscar una aproximaci√≥n nueva para 
desarrollar trabajos de investigaci√≥n usando las facilidades que nos brinda el Cloud Computing, y concretamente la resoluci√≥n de 
problemas de b√∫squeda representados mediante algoritmos Gen√©ticos, yendo m√°s all√° y sentando las bases de un framework como 
Hadoop Map Reduce, para la reducci√≥n de complejidad y tiempo en estos fines.



\section{Cloud Computing}

Cloud computing es a√∫n un paradigma en evoluci√≥n, sus definiciones, arquitecturas, modelos, casos de uso, tecnolog√≠as base, problemas, 
riesgos y beneficios, son continuamente redefinidos en debates promocionados por el sector p√∫blico y privado. En\cite{Bible2011} 
podemos ver varias  definiciones aunque muchos citan como m√°s precisa la definici√≥n dada por el NIST, se enuncia a continuaci√≥n.
Seg√∫n el NIST (National Institute of Standards and Technology) podemos definir el Cloud Computing como: 

\textit{Cloud Computing es un modelo para habilitar acceso conveniente por demanda a un conjunto compartido de recursos computacionales 
configurables, por ejemplo, redes, servidores, almacenamiento, aplicaciones y servicios, que pueden ser r√°pidamente proporcionados y 
liberados con un esfuerzo m√≠nimo de administraci√≥n o de interacci√≥n con el proveedor de servicios. Este modelo de nube promueve la 
disponibilidad y est√° compuesto por cinco caracter√≠sticas esenciales, tres modelos de servicio y cuatro modelos de despliegue. }



En un intento de adentrarse en lo que es y no es el Cloud computing compararemos este paradigma con la computaci√≥n tradicional, 
que ha habido hasta este tiempo. Con la computaci√≥n tradicional ejecutamos copias de software en cada ordenador. 
Los documentos que creamos  son almacenados en el ordenador en el que fueron creados. Aunque se puede acceder a los documentos desde 
otros ordenadores de la red, no se puede desde ordenadores de fuera de ella. 

Con cloud computing, los programas que usamos no se ejecutan en nuestro ordenador personal, sino que son almacenados en servidores 
accedidos v√≠a Internet. Si tu ordenador se rompiera, el software seguir√≠a estando operativo para los dem√°s. De la misma forma se hace 
para los documentos que creamos; son almacenados en una colecci√≥n de servidores. Cualquiera con permiso puede, no s√≥lo acceder a los 
documentos, sino tambi√©n editar y colaborar en dichos documentos en tiempo real. A diferencia de la computaci√≥n tradicional, el modelo 
de cloud no es PC-C√©ntrico. El dispositivo que se usa para acceder a la informaci√≥n no es lo m√°s importante. A continuaci√≥n, veremos 
qu√© es Cloud Computing y qu√© no es \cite{Web08} .

\subsection{Qu√© no es cloud computing}

Cloud computing no es una red de ordenadores. Con una red, las aplicaciones  y documentos son almacenados en un servidor de la empresa 
y accedidos a trav√©s de la red de la empresa. Cloud computing es mucho m√°s que esto. Engloba m√∫ltiples empresas, m√∫ltiples servidores y 
m√∫ltiples redes. A diferencia de una red de ordenadores, los servicios cloud y el almacenamiento pueden ser accedidos desde cualquier 
ordenador del mundo con una conexi√≥n a internet. 

Cloud computing tampoco es la subcontrataci√≥n de un servicio externo de manera tradicional, donde la compa√±√≠a contratada presta sus 
servicios a la empresa contratadora. Mientras una empresa de outsourcing organiza sus datos y aplicaciones, estos documentos y 
programas solamente son accesibles a los empleados de la empresa a trav√©s de la red de la misma, no a todo el mundo v√≠a internet.
As√≠ que, a pesar de las aparentes similitudes, las redes y el outsourcing no son cloud computing.


\subsection{Qu√© es cloud computing}

La clave de la definici√≥n de Cloud Computing es el Cloud en s√≠ mismo. Para nuestro prop√≥sito, el cloud es un gran conjunto de ordenadores 
interconectados. Estos computadores pueden ser PC's o servidores, p√∫blicos o privados. 

Esta nube de computadores se extiende m√°s all√° de una simple compa√±√≠a o empresa. Las aplicaciones y datos servidos por la nube est√°n 
disponibles para un amplio grupo de usuarios, a trav√©s de empresas y plataformas. El acceso es v√≠a Internet. Cualquier usuario autorizado 
puede acceder a estos documentos  y aplicaciones  desde cualquier ordenador con conexi√≥n a Internet. Y, para el usuario, la tecnolog√≠a e 
infraestructura que se esconde detr√°s de la nube es invisible. 



En general, como vemos en la figura\ref{Figura3} Cloud computing surge de la combinaci√≥n y agrupaci√≥n de tecnolog√≠a ya conocidas, que 
permiten obtener un nuevo enfoque y proyecci√≥n.


Para ejemplificar algunos de los puntos m√°s interesantes del cloud computing nos basaremos en Google, una de las principales 
compa√±√≠as impulsoras del Cloud. Seg√∫n su perspectiva, hay seis propiedades clave en el cloud computing.

\begin{itemize}

\item Es ``User-Centric'': Una vez que t√∫ eres un usuario conectado a la nube, cualquier cosa que haya almacenada all√≠ - documentos, mensajes, 
im√°genes, aplicaciones - se convierte en tuya. Adem√°s, no solo los datos son tuyos sino que puedes compartirlos con otros. 
En efecto, cualquier dispositivo que acceda a tus datos en la nube tambi√©n convierte los datos en suyos.
\item Es ``Task-Centric'': En vez de concentrarse en la aplicaci√≥n y qu√© hacer, se centra en lo que necesitas y c√≥mo la aplicaci√≥n puede 
hacerlo por ti. Las aplicaciones tradicionales - procesadores de textos, hojas de c√°lculo, email... -  se est√°n convirtiendo en m√°s 
importantes que los documentos que se crean.
\item Es poderoso: Conectando cientos o miles de computadores juntos en una nube se crea una riqueza de computaci√≥n imposible de hacer 
en un √∫nico PC.
\item Es accesible: Como los datos son almacenados en la nube, usuarios pueden recuperar informaci√≥n instant√°neamente desde m√∫ltiples 
repositorios. No est√°s limitado a una √∫nica fuente de datos, como lo est√°s en un PC.
\item Es inteligente: Con el volumen de datos almacenados en la nube, el data-mining y an√°lisis son necesarios para acceder a esta 
informaci√≥n de una manera inteligente.
\item Es programable: Muchas de las tareas necesarias para el cloud computing deben de ser automatizadas. Por ejemplo, para proteger 
la identidad de los datos, la informaci√≥n almacenada en un √∫nico computador en la nube debe ser replicada en los otros computadores 
de la nube. Si uno de √©stos falla, la programaci√≥n de la nube redistribuir√° autom√°ticamente los datos de √©ste computador hacia uno 
nuevo de la nube.

\end{itemize}

\section{Algoritmos Gen√©ticos}


La t√©cnica de b√∫squeda conocida como Algoritmo Gen√©tico se basa en los mecanismos de selecci√≥n que utiliza la naturaleza, 
de acuerdo a los cuales los individuos m√°s aptos de una poblaci√≥n son los que sobreviven, al adaptarse m√°s
f√°cilmente a los cambios que se producen en su entorno. Hoy en d√≠a se sabe que estos cambios se efect√∫an en los genes de 
un individuo (unidad b√°sica de codificaci√≥n de cada uno de los atributos de un ser vivo), 
y que sus atributos m√°s deseables (es decir, los quele permiten adaptarse mejor a su entorno) se transmiten a sus descendientes 
cuando √©ste se reproduce sexualmente. 

La primera menci√≥n del t√©rmino Algoritmo Gen√©tico, y la primera publicaci√≥n
sobre una aplicaci√≥n del mismo, se deben a J.D.Bagley \cite{Bagley67}, que dise√±√≥ AGs para
buscar conjuntos de par√°metros en funciones de evaluaci√≥n de juegos. 
Pero es otro cient√≠fico el considerado creador de los AGs: John Holland, que los desarroll√≥, junto a sus alumnos y colegas, 
durante los 60 y 70.  

El prop√≥sito original de Holland no era dise√±ar algoritmos para resolver problemas concretos, sino estudiar, de un modo formal, 
el fen√≥meno de la adaptaci√≥n tal y como ocurre en la naturaleza y desarrollar v√≠as de extrapolar esos mecanismos de adaptaci√≥n
natural a los sistemas computacionales.  

En \cite{Holland75} Holland presentaba el AG como una
abstracci√≥n de la evoluci√≥n biol√≥gica, y proporcionaba el entramado te√≥rico para la adaptaci√≥n bajo el algoritmo gen√©tico. 
El AG de Holland era un m√©todo para desplazarse, de una poblaci√≥n de cromosomas a una nueva poblaci√≥n, utilizando
un sistema similar a la selecci√≥n natural junto con los operadores de cruce, mutaci√≥n e inversi√≥n inspirados en la gen√©tica. 
En este primitivo algoritmo, cada cromosoma consta de genes (bits) y cada uno de ellos es una muestra de un alelo particular (0 √≥ 1). 
El operador de selecci√≥n escoge entre los cromosomas de la poblaci√≥n aquellos con capacidad de reproducci√≥n, y entre √©stos, 
los que sean m√°s compatibles producir√°n m√°s descendencia que el resto. El operador de cruce extrae partes de dos cromosomas,
imitando la combinaci√≥n biol√≥gica de dos cromosomas aislados (gametos). Y por √∫ltimo, el operador de mutaci√≥n se encarga de cambiar, 
de modo aleatorio, los valores del alelo en algunas localizaciones del cromosoma. 


\section{Fundamentos biol√≥gicos}

La computaci√≥n evolutiva, dentro de la que se encuadran los AGs, tiene una fuerte base biol√≥gica. Originalmente, 
los algoritmos evolutivos consist√≠an en copiar procesos que tienen lugar en la selecci√≥n natural. A pesar de que 
a√∫n hoy en d√≠a no todos los detalles de la evoluci√≥n biol√≥gica son completamente conocidos, existen algunos hechos apoyados 
sobre una fuerte evidencia experimental:

\begin{itemize}
 \item La evoluci√≥n es un proceso que opera, m√°s que sobre los propios organismos, sobre los cromosomas. Estos cromosomas son 
 partes del ADN portadores de los factores de la herencia o genes.
 \item La selecci√≥n natural es el proceso por el cual los organismos mejor adaptados desplazan lentamente organismos peor adaptados. 
 Este proceso conduce a la acumulaci√≥n lenta de cambios gen√©ticos favorables en una poblaci√≥n. Dicha selecci√≥n al operar a lo 
 largo de muchas generaciones puede cambiar los atributos b√°sicos de la poblaci√≥n original de organismos.
 \item Los procesos evolutivos tienen lugar durante la etapa de reproducci√≥n. Aunque existe una larga serie de mecanismos 
 que afectan a la misma, los m√°s comunes son la mutaci√≥n y el cruce o recombinaci√≥n.
\end{itemize}


En analog√≠a analog√≠a directa con el comportamiento natural, los AGs trabajan con una poblaci√≥n de individuos, cada uno de los cuales 
representa una posible soluci√≥n a un problema dado. A cada individuo se le asigna un valor o puntuaci√≥n, relacionado con la bondad 
de dicha soluci√≥n, llamado fitness. En la naturaleza, esto equivaldr√≠a al grado de efectividad de un organismo para competir por 
unos determinados recursos. Cuanto mayor sea la adaptaci√≥n de un individuo al problema, mayor ser√° la probabilidad de que el mismo 
sea seleccionado para reproducirse, cruzando su material gen√©tico con otro individuo seleccionado. Este cruce producir√° nuevos 
individuos -descendientes de los anteriores- los cuales comparten algunas de las caracter√≠sticas de sus padres. Cuanto
menor sea la adaptaci√≥n de un individuo, menor ser√° la probabilidad de que dicho individuo sea seleccionado para la reproducci√≥n, 
y por tanto de que su material gen√©tico se propague en sucesivas generaciones posteriores. De esta manera se produce una nueva poblaci√≥n
de posibles soluciones, la cual reemplaza a la anterior y verifica la propiedad de contener una mayor proporci√≥n de buenas 
caracter√≠sticas en comparaci√≥n con la poblaci√≥n anterior. As√≠ a lo largo de las generaciones las buenas caracter√≠sticas se
propagan a trav√©s de la poblaci√≥n.  Si el AG ha sido bien dise√±ado, la poblaci√≥n converger√° hacia una soluci√≥n √≥ptima del problema.

Seg√∫n \cite{Enfoque09} estas ideas est√°n enla base del dise√±o de los algoritmos evolutivos. Adem√°s, muchas de las propiedades de la
evoluci√≥n de los seres vivos, como la edad, la mayor o menor tendencia a la mutaci√≥n seg√∫n el estadio de la evoluci√≥n, etc. est√°n
siendo objeto de investigaci√≥n para su incorporaci√≥n a las t√©cnicas de computaci√≥n evolutiva. Sin embargo, los algoritmos evolutivos
no tratan de ser un reflejo fiel de la evoluci√≥n biol√≥gica. Debemos tener en cuenta que la naturaleza evoluciona a lo largo de millones
de a√±os, mientras que a nosotros nso interesa que nuestros algoritmos nos proporcionen una soluci√≥n en un tiempo algo m√°s corto.



\section{Algoritmo Gen√©tico B√°sico}

En esta secci√≥n se describen los componentes de un algoritmo gen√©tico b√°sico y sus formas m√°s comunes.

\subsection{Representaci√≥n de los Individuos}

Desde los primeros estudios de los AGs los individuos son cadenas binarias, siendo hoy en d√≠a a√∫n la aproximaci√≥n
m√°s utilizada, aunque existen otras que utilizan letras o valores n√∫mericos para representar a sus cromosomas. 
Podemos ver un ejemplo en la \ref{Figura9}


La sencillez de la representaci√≥n binaria que utilizan los AGs les aporta caracter√≠sticas muy importantes de eficiencia. 
Sin embargo debemos disponer de un m√©todo para poder evaluar la adecuaci√≥n del individuo como soluci√≥n al 
problema. L√≥gicamente, el m√©todo de transformaci√≥n es espec√≠fico del problema considerado. Sin embargo, a la hora de dise√±ar
el m√©todo de codificaci√≥n es importante tener en cuenta una serie de directrices. As√≠, debemos buscar una codificaci√≥n tal que
cada punto del espacio de b√∫squeda est√© representado por el mismo n√∫mero de cadenas binarias, y tal que sea capaz de representar
todos los puntos del espacio del problema. 

En el contexto de los AGs, el t√©rmino cromosoma se refiere a un candidato a soluci√≥n del problema, que frecuentemente es 
codificado como una cadena de bits. Los genes son tanto un bit como bloques cortos de bits adyacentes 
que codifican un elemento particular del candidato a soluci√≥n. Un alelo en una cadena de bits ser√° 
un 0 o un 1 (para alfabetos largos cada posici√≥n puede tener m√°s alelos). El genotipo de un individuo en un AG que emplea
cadenas de bits es, simplemente, la configuraci√≥n de bits del cromosoma de ese individuo. 

Cabe resaltar que en este trabajo usaremos tanto codificaci√≥n binaria como codificaci√≥n real que
consiste en exactamente lo mismo pero un gen es representado como un n√∫mero real, generalmente en un dominio dado por el 
problema. 


\subsection{Funcionamiento}

Sea X el problema a resolver, el esquema general de un algoritmo gen√©tico es el siguiente \cite{Her03}:




A continuaci√≥n se proceder√° a una explicaci√≥n exhaustiva de dicho algoritmo.
Dada una representaci√≥n de candidatos a soluciones en una cadena de bits, un AG simple, tal y como 
se describe en \cite{Mit98}, funcionar√≠a del siguiente modo:

\begin{enumerate}
 \item Comenzar con una poblaci√≥n P generada aleatoriamente de n cromosomas de L bits.
 \item Calcular el valor de la funci√≥n de evaluaci√≥n o fitness (f(x)) para cada cromosoma x de P.
 \item Repetir los siguientes pasos hasta que se hayan creado todos los  descendientes:
 \begin{enumerate}
    \item Seleccionar un par de cromosomas de P, siendo la probabilidad de selecci√≥n proporcional al fitness.
    Los cromosomas seleccionados ser√°n llamados cromosomas padre.
    \item Con probabilidad \textit{$p_c$} (tasa de cruce), cruzar el par de cromosomas padre en un punto (o m√°s)
    elegido aleatoriamente para formar dos descendientes. Si no tiene lugar ning√∫n cruce, formar dos descendientes que sean copias
    exactas de sus respectivos padres.
    \item Mutar los dos descendientes en cada lugar con probabilidad \textit{$p_m$} (tasa de mutaci√≥n), y colocar 
    los cromosomas resultantes en la nueva poblaci√≥n P'.
 \end{enumerate}
 \item Reemplazar la poblaci√≥n actual P con la nueva poblaci√≥n P'.
 \item Evaluar la condici√≥n de finalizaci√≥n.
 \item Volver al paso 2.

\end{enumerate}

En el paso 2 del algoritmo se habla de una funci√≥n de evaluaci√≥n, la cual debe ser dise√±ada para cada problema de manera 
espec√≠fica. Dado un cromosoma cualquiera, la funci√≥n de evaluaci√≥n le asigna un n√∫mero real, que se supone refleja el nivel de 
adaptaci√≥n al problema del  individuo representado por el cromosoma. 

Asimismo, la primera operaci√≥n del paso 3 del algoritmo es la llamada fase de selecci√≥n. Esta selecci√≥n se efect√∫a usando 
un procedimiento que favorezca a los individuos mejor adaptados. Existen diferentes m√©todos de selecci√≥n, que posteriormente
veremos. 

Cada iteraci√≥n de este proceso recibe el nombre de generaci√≥n.
Cada generaci√≥n se obtiene a partir de la anterior por medio de los llamados operadores de reproducci√≥n (paso 3 del algoritmo), 
que pueden ser de dos tipos:

\begin{enumerate}
 \item \textbf{Copia:} Es un tipo de reproducci√≥n asexual, en la que un determinado n√∫mero de individuos pasa directamente a la 
 siguiente generaci√≥n, sin sufrir ning√∫n proceso de variaci√≥n en sus genes.
 \item \textbf{Cruce:} Es una reproducci√≥n de tipo sexual en la que se genera una descendencia a partir de un n√∫mero fijo de 
 individuos, dos por lo general, de la generaci√≥n anterior. Existen varios tipos de cruce, que veremos m√°s tarde.
\end{enumerate}


El algoritmo acabar√° cuando se cumpla la condici√≥n de fin, que normalmente ser√° una de las siguientes:

\begin{enumerate}
 \item Se ha encontrado una soluci√≥n que satisface un criterio m√≠nimo.
 \item Se ha llegado a un n√∫mero determinado de generaciones establecido previamente.
 \item Se ha llegado a un l√≠mite preestablecido en tiempo de computaci√≥n.
 \item Tras varias generaciones el fitness de la mejor soluci√≥n no ha variado.
 \item Parada manual.
 \item Combinaci√≥n de las anteriores
\end{enumerate}

Posiblemente el criterio m√°s utilizado sea el primero, seg√∫n el cual De Jong en su tesis doctoral
\cite{John75} afirm√≥ que si el AG es correcto, la poblaci√≥n evolucionar√° a lo largo de las sucesivas generaciones de tal forma que la
evaluaci√≥n media entre todos los individuos, as√≠ como la propia del mejor individuo, converger√°n hacia el √≥ptimo global. 
Se dice que un gen ha convergido cuando al menos el 95\% de los individuos de la poblaci√≥n comparten el mismo valor para dicho gen. 
Se dice que la poblaci√≥n converge cuando todos los genes han convergido. Se puede generalizar dicha definici√≥n al caso en que al menos un
$\beta \%$ de los individuos de la poblaci√≥n hayan convergido. 

El esqueleto de este algoritmo es la base de la mayor√≠a de las aplicaciones de los algoritmos gen√©ticos. Se podr√≠a profundizar mucho m√°s 
en detalles sobre cuales deben ser las diferentes probabilidades, tama√±o de la poblaci√≥n y n√∫mero de generaciones. De esos detalles 
depender√°, en gran parte, el √©xito o fracaso de nuestro algoritmo.



\section{Modelo MapReduce}


Durante a√±os, los programadores se han visto forzados a realizar implementaciones espec√≠ficas para trabajar con grandes 
vol√∫menes de datos en sus entornos distribuidos de trabajo.

Pese a que no siempre es necesario, el tama√±o de la informaci√≥n entrante suele ser grande y los c√°lculos deben ser distribuidos 
entre una gran multitud de m√°quinas para acabar en un tiempo razonable. Los problemas de c√≥mo paralelizar estos c√°lculos, 
distribuir la informaci√≥n y manejar los fallos dificultan basatante la labor de implementaci√≥n. 

El modelo de programaci√≥n MapReduce es una propuesta que pretende resolver las dificultades anteriores, ya que sus caracter√≠sticas 
y motivaci√≥n se basan en la delegaci√≥n de los c√≥mputos intensivos en datos a un cl√∫ster de m√°quinas remotas que,
mediante un sistema de ficheros distribuido, repartir√°n la carga de trabajo, optimizando tiempo y recursos. 
Asimismo, facilita un patr√≥n de desarrollo paralelo para simplificar la implementaci√≥n de aplicaciones intensivas en 
datos en entornos distribuidos. Este modelo puede dividir un espacio grande de problema en espacios peque√±os y paralelizar 
la ejecuci√≥n de tareas m√°s peque√±as en estos sub-espacios. 

Este modelo ha cobrado especial inter√©s por su aplicabilidad en entornos de Cloud Computing \cite{Web08}. 
MapReduce ofrece unas ventajas muy directas y evidentes como es la centralizaci√≥n de los datos en servidores remotos, 
eliminando las dependencias con los soportes f√≠sicos; o la contrataci√≥n de servicios en funci√≥n de las
necesidades de las empresas, sin tener que a√±adir equipos, software o personal, lo que conlleva un considerable ahorro 
tambi√©n en el plano energ√©tico. 

Este cap√≠tulo se estructura en varias secciones. En la primera de ellas se introduce el modelo MapReduce, desarrollando sus
dos primitivas fundamentales: map y reduce. En siguientes secciones se ir√°n analizando las distintas implementaciones y 
ejemplos de uso, as√≠ como una visi√≥n general de Amaz√≥n Elastic MapReduce, la implementaci√≥n de este paradigma por parte de
Amazon.

\section{Introducci√≥n}

MapReduce \cite{Dea08} es un modelo de programaci√≥n, desarrollado por Google, que es utilizado para procesar grandes conjuntos de 
datos distribuidos a lo largo de un cl√∫ster de servidores. Este procesado computacional puede tener lugar tanto sobre datos
almacenados en sistemas de ficheros, como en bases de datos. El modelo de programaci√≥n est√° inspirado en los lenguajes funcionales 
y permite al desarrollador expresar sus algoritmos utilizando √∫nicamente dos funciones, \textbf{map} y \textbf{reduce}. 

Las funciones map y reduce de MapReduce se definen sobre datos estructurados en pares clave-valor. La funci√≥n map, escrita por el 
usuario, recibe un par clave-valor y devuelve un conjunto de pares clave-valor intermedio:

%\begin{equation}
%	map: (k1 , v1) \xrightarrow{} [(k2 , v2)] 
%  \label{EcuacionMap}
%\end{equation}


Esta funci√≥n (\ref{EcuacionMap})  se aplica en paralelo a cada par del conjunto de datos de entrada produciendo una lista de 
pares $(k2, v2)$ por cada llamada. MapReduce agrupa todos los valores intermedios asociados con la misma clave k y se los 
pasa a la funci√≥n reduce.

La funci√≥n reduce (\ref{EcuacionReduce}) recibe dicha clave y su conjunto de valores asociados y los fusiona para formar un conjunto 
de valores m√°s peque√±o:


%\begin{equation}
%	reduce: (k2 , [v2]) \xrightarrow{} [v3]
%	\label{EcuacionReduce}
%\end{equation}


Cada llamada reduce produce bien una lista v3 o un valor vac√≠o. Los resultados de las llamadas se recopilan en la lista de 
resultados buscada. 




Desde la perspectiva del flujo de datos, la ejecuci√≥n de MapReduce consiste en M tareas map y R tareas reduce independientes. 
Generalmente, los resultados intermedios se particionan en R trozos para R tareas reduce. La Figura \ref{Figura20} muestra el 
flujo de datos de alto nivel de un trabajo MapReduce.



Los principales elementos de un flujo de trabajo MapReduce son los siguientes:

\begin{itemize}
 \item \textbf{Proceso que lee la entrada}: divide los datos de entrada en bloques, siendo asignados cada uno de estos bloques a la 
 funci√≥n map correspondiente. Estos datos ser√°n le√≠dos de un almacenamiento estable y generar√° pares clave/valor. 
 Un ejemplo com√∫n ser√≠a la lectura de un directorio entero, y la devoluci√≥n de un registro por cada l√≠nea de cada fichero.

 \item \textbf{Funci√≥n de mapeo} (map): Cada funci√≥n map recibe una serie de pares clave-valor, los procesa individualmente, y 
 devuelve cero o m√°s pares clave-valor de salida. Los tipos de datos de la entrada y la salida de la funci√≥n map suele ser
distintos. Por ejemplo, si la aplicaci√≥n realizase un conteo de palabras, la funci√≥n map separar√≠a la l√≠nea en palabras y 
sacar√≠a como resultado la palabra como clave y un 1 como valor.
 
 \item \textbf{Funci√≥n de partici√≥n}: Las salidas de cada uno de los nodos map son asignadas a un nodo reduce en concreto a 
 partir del resultado obtenido por la funci√≥n ``partition'' de la aplicaci√≥n. Esta funci√≥n devuelve el √≠ndice del reduce buscado, 
 dada una clave y un n√∫mero de nodo reduce. Una funci√≥n t√≠pica es hallar el valor hash de la clave y hacer m√≥dulo del n√∫mero 
 de nodo reduce.

 \item \textbf{Funci√≥n de comparaci√≥n}: La entrada de cada reduce se obtiene de la m√°quina en la que se ejecut√≥ y orden√≥ el 
 map utilizando la funci√≥n de comparaci√≥n de la aplicaci√≥n.

 \item \textbf{Funci√≥n de escritura de salida}: Escribe la salida de la funci√≥n reduce en un almacenamiento estable, t√≠picamente 
 un sistema de ficheros distribuido.
 
\end{itemize}

El principal beneficio de este modelo de programaci√≥n es la simplicidad. El programador simplemente proporciona una descripci√≥n 
del algoritmo centrada en su funcionalidad.





\section{Experimentos}

\section{Conclusiones y trabajo futuro}
\label{sec:conc}




El Cloud Computing ha llegado con mucha fuerza y todo hace indicar que viene para quedarse.  Hemos visto durante, 
la primera parte que son muchas m√°s las ventajas que nos ofrece este modelo que los inconvenientes a los que nos podemos 
enfrentar.  

Todo proveedor de computaci√≥n en la nube, nos ofrece una infraestructura que, a no ser que estemos en una gran empresa o 
seamos poseedores de superordenadores, no est√° a nuestro alcance y ello nos hace que instant√°neamente podamos acceder 
a esos recursos y hacer uso de ellos de una forma r√°pida, sencilla y con un coste bajo.  Precisamente esta posibilidad hace que 
sea una tecnolog√≠a verdaderamente interesante para el mundo cient√≠fico e investigador, pues habitualmente en tareas como 
an√°lisis financiero, meteorol√≥gico o bioinform√°tica, entre otras muchas cosas, se trabaja con ingentes cantidades de datos 
que requieren de millones de c√°lculos en poco tiempo y precisan de mucho tiempo, pese a tener grandes centros de datos. 

Por ello en este trabajo se ha propuesto un peque√±o estudio dentro del gran mundo que es la bioinform√°tica, utilizando 
la infraestructura de Amazon, el mayor proveedor de Cloud Computing y mucho m√°s configurable que Google App Engine,
para la ejecuci√≥n y an√°lisis de algoritmos gen√©ticos b√°sicos.  

Se ha implementado una peque√±a librer√≠a para el dise√±o de algoritmos gen√©ticos de forma secuencial y un completo manual para 
la ejecuci√≥n de estos algoritmos en los servicios web de Amazon.  Las caracter√≠sticas m√°s importantes de esta propuesta han sido:

\begin{itemize}
 \item \textbf{Extensibilidad:} Desde el primer momento de desarrollo se ha pretendido dotar a la librer√≠a de un car√°cter extensible, 
 abstrayendo todo lo posible los distintos elementos dentro de un AG con el uso de interfaces, herencia y dem√°s 
 ventajas de un lenguaje como Java y facilitando el prototipado r√°pido de AGs  mediante la implementaci√≥n de un n√∫mero m√≠nimo de 
 funciones.

 \item \textbf{Portabilidad}: La aplicaci√≥n se encapsula en un fichero JAR que puede ser ejecutado en cualquier entorno anfitri√≥n que 
 disponga de un compilador Java, independientemente de su sistema operativo. Esto se ha hecho as√≠, porque el objetivo principal e
 era ver las ventajas de computaci√≥n en la nube, y lo mejor era un sistema portable entre distintas instancias vol√°tiles en 
 Amazon EC2.

 \item \textbf{Sencillez}: El objetivo principal del trabajo, era conocer un poco m√°s distintas posibilidades de servicios de la 
 nube de Amazon y como facilita el an√°lisis de datos  y no profundizar mucho en Algoritmos Gen√©ticos, por esta raz√≥n se han 
 implementado tres funciones sencillas. El √∫nico conocimiento necesario para realizar las pruebas viene explicado detalladamente 
 en el documento adjunto o la documentaci√≥n generada por cada proyecto.
 
 \item \textbf{Aprendizaje}: Este trabajo es v√°lido tanto como para alguien quiera iniciarse en el conocimiento de los algoritmos 
 gen√©ticos, como para alguien que quiere sentar las bases de Cloud Computing tener acceso a instancias virtuales en Amazon.
 
\end{itemize}


Una vez vistos hecho el an√°lisis de los resultados de la versi√≥n secuencial surgi√≥ la posibilidad de buscar una alterantiva  
paralela para un algoritmo gen√©tico  e investigando se encontr√≥ la posibilidad de  usar MapReduce, por ello, se ha descrito 
te√≥ricamente en que consiste este modelo y en concreto, la implementaci√≥n por parte de  Hadoop, que es la 
m√°s conocida. 


Para introducirnos en el mundo de Hadoop, se ha explicado como hacer una configuraci√≥n pseudo-distribuida en nuestro pc para 
comenzar a escribir aplicaciones de este tipo. Como primer ejemplo de ello, se ha propuesto y explicado la 
implementaci√≥n de un b√°sico contador de frecuencias de palabras en un conjunto de archivos, 
que pese a ser sencillo, nos da una muestra del potencial de MapReduce y de la sencillez de su implementaci√≥n.  


Como extensi√≥n se ha presentado una aproximaci√≥n a un sistema capaz de adaptar la naturaleza intensiva en datos del modelo MapReduce con el car√°cter 
iterativo de un Algoritmo Gen√©tico, sentando las bases para construir un software que permita ejecutar de forma distribuida 
algoritmos gen√©ticos paralelos tanto sobre cl√∫sters, como sobre el servicio que nos proporciona Amazon Elastic MapReduce.  


En l√≠neas generales, se ha descrito el dise√±o y la implementaci√≥n de AGs b√°sicos tanto de forma secuencial  como paralela utilizando 
entornos secuenciales y de cloud computing con Amazon como proveedor, y se ha introducido al uso del Framework de Hadoop para el 
dise√±o de aplicaciones con MapReduce.


Por √∫ltimo, destacar que las pruebas realizadas con la bater√≠a de problemas elegida (``Rastrigin'', ``OneMAX'' y ``Marea'') arrojan 
resultados satisfactorios en cuanto a escalabilidad y tiempo, teniendo en cuenta adem√°s que nuestra computadora desde la que 
mandamos los trabajos no consume recurso alguno. 


\section*{Futuras l√≠neas de trabajo}


Hasta el momento solo ha podido desarrollarse un modelo de c√≥mo ser√≠a la implementaci√≥n de un algoritmo gen√©tico paralelo 
usando MapReduce.  La principal l√≠nea de trabajo ser√≠a terminar la implementaci√≥n de este modelo y hacer extensible 
las clases implementadas para la parte secuencial a la parte paralela.

Dentro de la l√≠nea seguida en el proyecto podemos contemplar otras alternativas que completar√≠an el estudio del modelo de 
programaci√≥n MapReduce:

\begin{itemize}
 \item Se podr√≠a investigar si compensa la generaci√≥n inicial de individuos con una tarea MapReduce como propone \cite{Gen09}. 
Esto ser√≠a √∫til para utilizar poblaciones de gran tama√±o ya que en este caso, tendr√≠a un costo inicial muy alto para el 
nodo maestro mientras los otros se encontrar√≠an ociosos.
 \item Otro aspecto que podr√≠a ser estudiado es la definici√≥n de una clase personalizada InputFormat (la encargada de describir la 
especificaci√≥n de los datos de entrada de un trabajo MapReduce) para poder configurar el n√∫mero de tareas map a gusto del usuario.
\end{itemize}

En lo que engloba al Cloud Computing, hay varias opciones que me gustar√≠a llevar a cabo:

\begin{itemize}
 \item Mover una aplicaci√≥n a la nube, migrar sus datos, configurar una  instancia para que no sea vol√°til, contratando una ip est√°tica  y que 
 √©sta act√∫e como servidor, y montar una p√°gina web en ella. 
 \item Utilizar proveedores PaaS, como Windows Azure o Google App Engine para desarrollar un servicio en la web. 
\end{itemize}


En conclusi√≥n, pr√°cticamente para cualquier cosa en Internet se puede usar el Cloud Computing o aprovecharse de √©l, s√≥lo se ha visto 
una peque√±a parte, pero hay mucha luz detr√°s de las nubes.


% Eh.. un poco escaso, øno?
\bibliographystyle{splncs}
\bibliography{cloudproject}
\end{document}
