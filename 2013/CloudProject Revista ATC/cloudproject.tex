\documentclass[runningheads]{llncs}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
%%%%
\usepackage{color}
\usepackage{alltt}
\usepackage{verbatim}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
%%
\usepackage{url}
\urldef{\mailsa}\path|{pgarcia,pedro}@atc.ugr.es|

\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\begin{document}
 \pagestyle{empty} %ESTO QUITA LOS N칔MEROS DE P츼GINA
\mainmatter  % start of an individual contribution

% first the title is needed
\title{Estudio sobre algoritmos gen칠ticos en la nube y el modelo de programaci칩n MapReduce\thanks{Financiado con los proyectos EvOrq (TIC-3903) y Beca FPU AP2009-2942. }}

% Mete tambi輹 el del ministerio, que estaba vigente cuando el PFC. 

% a short form should be given in case it is too long for the running head
\titlerunning{Estudio sobre AGs en la nube}

% the name(s) of the author(s) follow(s) next
%
% NB: Chinese authors should write their first names(s) in front of
% their surnames. This ensures that the names appear correctly in
% the running heads and the author index.
%
\author{G. Mu\~noz \inst{1} \and Pablo Garc\'ia-S\'anchez\inst{1}  \and Pedro A. Castillo\inst{1}  \and Quien sea \inst{1}}
%
\authorrunning{P. Garc\'ia-S\'anchez et al.}
% (feature abused for this document to repeat the title also on left hand pages)

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
\institute{Dept. de Arquitectura y Tecnolog칤a de los Computadores, Universidad de Granada\\
\mailsa}


%
% NB: a more complex sample for affiliations and the mapping to the
% corresponding authors can be found in the file "llncs.dem"
% (search for the string "\mainmatter" where a contribution starts).
% "llncs.dem" accompanies the document class "llncs.cls".
%

\toctitle{Estudio sobre algoritmos gen칠ticos en la nube y el modelo de programaci칩n MapReduce}
\tocauthor{Authors' Instructions}
\maketitle


\begin{abstract}
Este trabajo presenta el proyecto fin de carrera Estudio sobre algoritmos gen칠ticos en la nube y el modelo de progrmaci칩n MapReduce.

\end{abstract}


\section{Introducci칩n}
\noindent En la 칰ltima d칠cada Internet ha transformado nuestra econom칤a y nuestra sociedad. Ha demostrado ser una infraestructura de comunicaci칩n 
y enlace de gran valor que se adapta gradualmente a las necesidades de los usuarios. Con Internet se ha creado una red mundial de 
intercambio de conocimientos, creatividad y colaboraci칩n. 

Del mismo modo, Internet ha dado un gran salto adelante gracias al despliegue de la banda ancha de muy alta velocidad, lo que ha 
permitido el lanzamiento de muchos nuevos servicios interactivos y de contenido. 

Todo esto hace que los programas inform치ticos ofertados en la red como un servicio disminuyan sus costes y aumenten su eficacia, 
provocando una gran mejora de la productividad. Desplegado adecuadamente, el llamado Internet del futuro, que cada vez es m치s 
presente, trae consigo innovaci칩n, aumento de la productividad, nuevos mercados y m치s crecimiento y empleo en esta d칠cada que 
reci칠n acabamos de comenzar. 

En este marco se engloba el Cloud Computing, un nuevo modelo de negocio en Internet, que beneficia tanto al proveedor de 
servicios en la nube como al usuario, capaz de tener acceso instant치neo a una infraestructura barata, escalable y f치cilmente 
accesible. 
 
Paralelamente a esta transformaci칩n, la ciencia ha estado evolucionando constantemente durante los 칰ltimos lustros, en gran parte, 
gracias al uso  de la tecnolog칤a. La investigaci칩n cient칤fica avanza al un칤sono con 칠sta, pues un cambio tecnol칩gico, la mayor칤a 
de las veces, abre un nuevo abanico de posibilidades para la comunidad cient칤fica, puesto que, independientemente de que se trate 
de investigaci칩n y desarrollo en un 치mbito cl칤nico, cient칤fico o industrial, existen m칰ltiples par치metros, como el uso intensivo 
de tecnolog칤as y procesamiento de datos, que son comunes e independientes del sector en el que se desarrollen. 

Dentro de la investigaci칩n existe adem치s en los 칰ltimos tiempos un crecimiento exponencial del volumen de datos necesario para 
resolver los cada vez m치s complejos problemas presentes en el d칤a a d칤a de un cient칤fico o investigador. Dentro de estos conjuntos 
de problemas se encuentran los de b칰squeda, a menudo representados por medio de Algoritmos Gen칠ticos, que se usan cada vez m치s en 
escenarios de gran complejidad. 


Sentando estos principios evidentes en la sociedad actual, el motivo de este trabajo es el de buscar una aproximaci칩n nueva para 
desarrollar trabajos de investigaci칩n usando las facilidades que nos brinda el Cloud Computing, y concretamente la resoluci칩n de 
problemas de b칰squeda representados mediante algoritmos Gen칠ticos, yendo m치s all치 y sentando las bases de un framework como 
Hadoop Map Reduce, para la reducci칩n de complejidad y tiempo en estos fines.



\section{Cloud Computing}

Cloud computing es a칰n un paradigma en evoluci칩n, sus definiciones, arquitecturas, modelos, casos de uso, tecnolog칤as base, problemas, 
riesgos y beneficios, son continuamente redefinidos en debates promocionados por el sector p칰blico y privado. En\cite{Bible2011} 
podemos ver varias  definiciones aunque muchos citan como m치s precisa la definici칩n dada por el NIST, se enuncia a continuaci칩n.
Seg칰n el NIST (National Institute of Standards and Technology) podemos definir el Cloud Computing como: 

\textit{Cloud Computing es un modelo para habilitar acceso conveniente por demanda a un conjunto compartido de recursos computacionales 
configurables, por ejemplo, redes, servidores, almacenamiento, aplicaciones y servicios, que pueden ser r치pidamente proporcionados y 
liberados con un esfuerzo m칤nimo de administraci칩n o de interacci칩n con el proveedor de servicios. Este modelo de nube promueve la 
disponibilidad y est치 compuesto por cinco caracter칤sticas esenciales, tres modelos de servicio y cuatro modelos de despliegue. }



En un intento de adentrarse en lo que es y no es el Cloud computing compararemos este paradigma con la computaci칩n tradicional, 
que ha habido hasta este tiempo. Con la computaci칩n tradicional ejecutamos copias de software en cada ordenador. 
Los documentos que creamos  son almacenados en el ordenador en el que fueron creados. Aunque se puede acceder a los documentos desde 
otros ordenadores de la red, no se puede desde ordenadores de fuera de ella. 

Con cloud computing, los programas que usamos no se ejecutan en nuestro ordenador personal, sino que son almacenados en servidores 
accedidos v칤a Internet. Si tu ordenador se rompiera, el software seguir칤a estando operativo para los dem치s. De la misma forma se hace 
para los documentos que creamos; son almacenados en una colecci칩n de servidores. Cualquiera con permiso puede, no s칩lo acceder a los 
documentos, sino tambi칠n editar y colaborar en dichos documentos en tiempo real. A diferencia de la computaci칩n tradicional, el modelo 
de cloud no es PC-C칠ntrico. El dispositivo que se usa para acceder a la informaci칩n no es lo m치s importante. A continuaci칩n, veremos 
qu칠 es Cloud Computing y qu칠 no es \cite{Web08} .

\subsection{Qu칠 no es cloud computing}

Cloud computing no es una red de ordenadores. Con una red, las aplicaciones  y documentos son almacenados en un servidor de la empresa 
y accedidos a trav칠s de la red de la empresa. Cloud computing es mucho m치s que esto. Engloba m칰ltiples empresas, m칰ltiples servidores y 
m칰ltiples redes. A diferencia de una red de ordenadores, los servicios cloud y el almacenamiento pueden ser accedidos desde cualquier 
ordenador del mundo con una conexi칩n a internet. 

Cloud computing tampoco es la subcontrataci칩n de un servicio externo de manera tradicional, donde la compa침칤a contratada presta sus 
servicios a la empresa contratadora. Mientras una empresa de outsourcing organiza sus datos y aplicaciones, estos documentos y 
programas solamente son accesibles a los empleados de la empresa a trav칠s de la red de la misma, no a todo el mundo v칤a internet.
As칤 que, a pesar de las aparentes similitudes, las redes y el outsourcing no son cloud computing.


\subsection{Qu칠 es cloud computing}

La clave de la definici칩n de Cloud Computing es el Cloud en s칤 mismo. Para nuestro prop칩sito, el cloud es un gran conjunto de ordenadores 
interconectados. Estos computadores pueden ser PC's o servidores, p칰blicos o privados. 

Esta nube de computadores se extiende m치s all치 de una simple compa침칤a o empresa. Las aplicaciones y datos servidos por la nube est치n 
disponibles para un amplio grupo de usuarios, a trav칠s de empresas y plataformas. El acceso es v칤a Internet. Cualquier usuario autorizado 
puede acceder a estos documentos  y aplicaciones  desde cualquier ordenador con conexi칩n a Internet. Y, para el usuario, la tecnolog칤a e 
infraestructura que se esconde detr치s de la nube es invisible. 



En general, como vemos en la figura\ref{Figura3} Cloud computing surge de la combinaci칩n y agrupaci칩n de tecnolog칤a ya conocidas, que 
permiten obtener un nuevo enfoque y proyecci칩n.


Para ejemplificar algunos de los puntos m치s interesantes del cloud computing nos basaremos en Google, una de las principales 
compa침칤as impulsoras del Cloud. Seg칰n su perspectiva, hay seis propiedades clave en el cloud computing.

\begin{itemize}

\item Es ``User-Centric'': Una vez que t칰 eres un usuario conectado a la nube, cualquier cosa que haya almacenada all칤 - documentos, mensajes, 
im치genes, aplicaciones - se convierte en tuya. Adem치s, no solo los datos son tuyos sino que puedes compartirlos con otros. 
En efecto, cualquier dispositivo que acceda a tus datos en la nube tambi칠n convierte los datos en suyos.
\item Es ``Task-Centric'': En vez de concentrarse en la aplicaci칩n y qu칠 hacer, se centra en lo que necesitas y c칩mo la aplicaci칩n puede 
hacerlo por ti. Las aplicaciones tradicionales - procesadores de textos, hojas de c치lculo, email... -  se est치n convirtiendo en m치s 
importantes que los documentos que se crean.
\item Es poderoso: Conectando cientos o miles de computadores juntos en una nube se crea una riqueza de computaci칩n imposible de hacer 
en un 칰nico PC.
\item Es accesible: Como los datos son almacenados en la nube, usuarios pueden recuperar informaci칩n instant치neamente desde m칰ltiples 
repositorios. No est치s limitado a una 칰nica fuente de datos, como lo est치s en un PC.
\item Es inteligente: Con el volumen de datos almacenados en la nube, el data-mining y an치lisis son necesarios para acceder a esta 
informaci칩n de una manera inteligente.
\item Es programable: Muchas de las tareas necesarias para el cloud computing deben de ser automatizadas. Por ejemplo, para proteger 
la identidad de los datos, la informaci칩n almacenada en un 칰nico computador en la nube debe ser replicada en los otros computadores 
de la nube. Si uno de 칠stos falla, la programaci칩n de la nube redistribuir치 autom치ticamente los datos de 칠ste computador hacia uno 
nuevo de la nube.

\end{itemize}

\section{Algoritmos Gen칠ticos}


La t칠cnica de b칰squeda conocida como Algoritmo Gen칠tico se basa en los mecanismos de selecci칩n que utiliza la naturaleza, 
de acuerdo a los cuales los individuos m치s aptos de una poblaci칩n son los que sobreviven, al adaptarse m치s
f치cilmente a los cambios que se producen en su entorno. Hoy en d칤a se sabe que estos cambios se efect칰an en los genes de 
un individuo (unidad b치sica de codificaci칩n de cada uno de los atributos de un ser vivo), 
y que sus atributos m치s deseables (es decir, los quele permiten adaptarse mejor a su entorno) se transmiten a sus descendientes 
cuando 칠ste se reproduce sexualmente. 

La primera menci칩n del t칠rmino Algoritmo Gen칠tico, y la primera publicaci칩n
sobre una aplicaci칩n del mismo, se deben a J.D.Bagley \cite{Bagley67}, que dise침칩 AGs para
buscar conjuntos de par치metros en funciones de evaluaci칩n de juegos. 
Pero es otro cient칤fico el considerado creador de los AGs: John Holland, que los desarroll칩, junto a sus alumnos y colegas, 
durante los 60 y 70.  

El prop칩sito original de Holland no era dise침ar algoritmos para resolver problemas concretos, sino estudiar, de un modo formal, 
el fen칩meno de la adaptaci칩n tal y como ocurre en la naturaleza y desarrollar v칤as de extrapolar esos mecanismos de adaptaci칩n
natural a los sistemas computacionales.  

En \cite{Holland75} Holland presentaba el AG como una
abstracci칩n de la evoluci칩n biol칩gica, y proporcionaba el entramado te칩rico para la adaptaci칩n bajo el algoritmo gen칠tico. 
El AG de Holland era un m칠todo para desplazarse, de una poblaci칩n de cromosomas a una nueva poblaci칩n, utilizando
un sistema similar a la selecci칩n natural junto con los operadores de cruce, mutaci칩n e inversi칩n inspirados en la gen칠tica. 
En este primitivo algoritmo, cada cromosoma consta de genes (bits) y cada uno de ellos es una muestra de un alelo particular (0 칩 1). 
El operador de selecci칩n escoge entre los cromosomas de la poblaci칩n aquellos con capacidad de reproducci칩n, y entre 칠stos, 
los que sean m치s compatibles producir치n m치s descendencia que el resto. El operador de cruce extrae partes de dos cromosomas,
imitando la combinaci칩n biol칩gica de dos cromosomas aislados (gametos). Y por 칰ltimo, el operador de mutaci칩n se encarga de cambiar, 
de modo aleatorio, los valores del alelo en algunas localizaciones del cromosoma. 


\section{Fundamentos biol칩gicos}

La computaci칩n evolutiva, dentro de la que se encuadran los AGs, tiene una fuerte base biol칩gica. Originalmente, 
los algoritmos evolutivos consist칤an en copiar procesos que tienen lugar en la selecci칩n natural. A pesar de que 
a칰n hoy en d칤a no todos los detalles de la evoluci칩n biol칩gica son completamente conocidos, existen algunos hechos apoyados 
sobre una fuerte evidencia experimental:

\begin{itemize}
 \item La evoluci칩n es un proceso que opera, m치s que sobre los propios organismos, sobre los cromosomas. Estos cromosomas son 
 partes del ADN portadores de los factores de la herencia o genes.
 \item La selecci칩n natural es el proceso por el cual los organismos mejor adaptados desplazan lentamente organismos peor adaptados. 
 Este proceso conduce a la acumulaci칩n lenta de cambios gen칠ticos favorables en una poblaci칩n. Dicha selecci칩n al operar a lo 
 largo de muchas generaciones puede cambiar los atributos b치sicos de la poblaci칩n original de organismos.
 \item Los procesos evolutivos tienen lugar durante la etapa de reproducci칩n. Aunque existe una larga serie de mecanismos 
 que afectan a la misma, los m치s comunes son la mutaci칩n y el cruce o recombinaci칩n.
\end{itemize}


En analog칤a analog칤a directa con el comportamiento natural, los AGs trabajan con una poblaci칩n de individuos, cada uno de los cuales 
representa una posible soluci칩n a un problema dado. A cada individuo se le asigna un valor o puntuaci칩n, relacionado con la bondad 
de dicha soluci칩n, llamado fitness. En la naturaleza, esto equivaldr칤a al grado de efectividad de un organismo para competir por 
unos determinados recursos. Cuanto mayor sea la adaptaci칩n de un individuo al problema, mayor ser치 la probabilidad de que el mismo 
sea seleccionado para reproducirse, cruzando su material gen칠tico con otro individuo seleccionado. Este cruce producir치 nuevos 
individuos -descendientes de los anteriores- los cuales comparten algunas de las caracter칤sticas de sus padres. Cuanto
menor sea la adaptaci칩n de un individuo, menor ser치 la probabilidad de que dicho individuo sea seleccionado para la reproducci칩n, 
y por tanto de que su material gen칠tico se propague en sucesivas generaciones posteriores. De esta manera se produce una nueva poblaci칩n
de posibles soluciones, la cual reemplaza a la anterior y verifica la propiedad de contener una mayor proporci칩n de buenas 
caracter칤sticas en comparaci칩n con la poblaci칩n anterior. As칤 a lo largo de las generaciones las buenas caracter칤sticas se
propagan a trav칠s de la poblaci칩n.  Si el AG ha sido bien dise침ado, la poblaci칩n converger치 hacia una soluci칩n 칩ptima del problema.

Seg칰n \cite{Enfoque09} estas ideas est치n enla base del dise침o de los algoritmos evolutivos. Adem치s, muchas de las propiedades de la
evoluci칩n de los seres vivos, como la edad, la mayor o menor tendencia a la mutaci칩n seg칰n el estadio de la evoluci칩n, etc. est치n
siendo objeto de investigaci칩n para su incorporaci칩n a las t칠cnicas de computaci칩n evolutiva. Sin embargo, los algoritmos evolutivos
no tratan de ser un reflejo fiel de la evoluci칩n biol칩gica. Debemos tener en cuenta que la naturaleza evoluciona a lo largo de millones
de a침os, mientras que a nosotros nso interesa que nuestros algoritmos nos proporcionen una soluci칩n en un tiempo algo m치s corto.



\section{Algoritmo Gen칠tico B치sico}

En esta secci칩n se describen los componentes de un algoritmo gen칠tico b치sico y sus formas m치s comunes.

\subsection{Representaci칩n de los Individuos}

Desde los primeros estudios de los AGs los individuos son cadenas binarias, siendo hoy en d칤a a칰n la aproximaci칩n
m치s utilizada, aunque existen otras que utilizan letras o valores n칰mericos para representar a sus cromosomas. 
Podemos ver un ejemplo en la \ref{Figura9}


La sencillez de la representaci칩n binaria que utilizan los AGs les aporta caracter칤sticas muy importantes de eficiencia. 
Sin embargo debemos disponer de un m칠todo para poder evaluar la adecuaci칩n del individuo como soluci칩n al 
problema. L칩gicamente, el m칠todo de transformaci칩n es espec칤fico del problema considerado. Sin embargo, a la hora de dise침ar
el m칠todo de codificaci칩n es importante tener en cuenta una serie de directrices. As칤, debemos buscar una codificaci칩n tal que
cada punto del espacio de b칰squeda est칠 representado por el mismo n칰mero de cadenas binarias, y tal que sea capaz de representar
todos los puntos del espacio del problema. 

En el contexto de los AGs, el t칠rmino cromosoma se refiere a un candidato a soluci칩n del problema, que frecuentemente es 
codificado como una cadena de bits. Los genes son tanto un bit como bloques cortos de bits adyacentes 
que codifican un elemento particular del candidato a soluci칩n. Un alelo en una cadena de bits ser치 
un 0 o un 1 (para alfabetos largos cada posici칩n puede tener m치s alelos). El genotipo de un individuo en un AG que emplea
cadenas de bits es, simplemente, la configuraci칩n de bits del cromosoma de ese individuo. 

Cabe resaltar que en este trabajo usaremos tanto codificaci칩n binaria como codificaci칩n real que
consiste en exactamente lo mismo pero un gen es representado como un n칰mero real, generalmente en un dominio dado por el 
problema. 


\subsection{Funcionamiento}

Sea X el problema a resolver, el esquema general de un algoritmo gen칠tico es el siguiente \cite{Her03}:




A continuaci칩n se proceder치 a una explicaci칩n exhaustiva de dicho algoritmo.
Dada una representaci칩n de candidatos a soluciones en una cadena de bits, un AG simple, tal y como 
se describe en \cite{Mit98}, funcionar칤a del siguiente modo:

\begin{enumerate}
 \item Comenzar con una poblaci칩n P generada aleatoriamente de n cromosomas de L bits.
 \item Calcular el valor de la funci칩n de evaluaci칩n o fitness (f(x)) para cada cromosoma x de P.
 \item Repetir los siguientes pasos hasta que se hayan creado todos los  descendientes:
 \begin{enumerate}
    \item Seleccionar un par de cromosomas de P, siendo la probabilidad de selecci칩n proporcional al fitness.
    Los cromosomas seleccionados ser치n llamados cromosomas padre.
    \item Con probabilidad \textit{$p_c$} (tasa de cruce), cruzar el par de cromosomas padre en un punto (o m치s)
    elegido aleatoriamente para formar dos descendientes. Si no tiene lugar ning칰n cruce, formar dos descendientes que sean copias
    exactas de sus respectivos padres.
    \item Mutar los dos descendientes en cada lugar con probabilidad \textit{$p_m$} (tasa de mutaci칩n), y colocar 
    los cromosomas resultantes en la nueva poblaci칩n P'.
 \end{enumerate}
 \item Reemplazar la poblaci칩n actual P con la nueva poblaci칩n P'.
 \item Evaluar la condici칩n de finalizaci칩n.
 \item Volver al paso 2.

\end{enumerate}

En el paso 2 del algoritmo se habla de una funci칩n de evaluaci칩n, la cual debe ser dise침ada para cada problema de manera 
espec칤fica. Dado un cromosoma cualquiera, la funci칩n de evaluaci칩n le asigna un n칰mero real, que se supone refleja el nivel de 
adaptaci칩n al problema del  individuo representado por el cromosoma. 

Asimismo, la primera operaci칩n del paso 3 del algoritmo es la llamada fase de selecci칩n. Esta selecci칩n se efect칰a usando 
un procedimiento que favorezca a los individuos mejor adaptados. Existen diferentes m칠todos de selecci칩n, que posteriormente
veremos. 

Cada iteraci칩n de este proceso recibe el nombre de generaci칩n.
Cada generaci칩n se obtiene a partir de la anterior por medio de los llamados operadores de reproducci칩n (paso 3 del algoritmo), 
que pueden ser de dos tipos:

\begin{enumerate}
 \item \textbf{Copia:} Es un tipo de reproducci칩n asexual, en la que un determinado n칰mero de individuos pasa directamente a la 
 siguiente generaci칩n, sin sufrir ning칰n proceso de variaci칩n en sus genes.
 \item \textbf{Cruce:} Es una reproducci칩n de tipo sexual en la que se genera una descendencia a partir de un n칰mero fijo de 
 individuos, dos por lo general, de la generaci칩n anterior. Existen varios tipos de cruce, que veremos m치s tarde.
\end{enumerate}


El algoritmo acabar치 cuando se cumpla la condici칩n de fin, que normalmente ser치 una de las siguientes:

\begin{enumerate}
 \item Se ha encontrado una soluci칩n que satisface un criterio m칤nimo.
 \item Se ha llegado a un n칰mero determinado de generaciones establecido previamente.
 \item Se ha llegado a un l칤mite preestablecido en tiempo de computaci칩n.
 \item Tras varias generaciones el fitness de la mejor soluci칩n no ha variado.
 \item Parada manual.
 \item Combinaci칩n de las anteriores
\end{enumerate}

Posiblemente el criterio m치s utilizado sea el primero, seg칰n el cual De Jong en su tesis doctoral
\cite{John75} afirm칩 que si el AG es correcto, la poblaci칩n evolucionar치 a lo largo de las sucesivas generaciones de tal forma que la
evaluaci칩n media entre todos los individuos, as칤 como la propia del mejor individuo, converger치n hacia el 칩ptimo global. 
Se dice que un gen ha convergido cuando al menos el 95\% de los individuos de la poblaci칩n comparten el mismo valor para dicho gen. 
Se dice que la poblaci칩n converge cuando todos los genes han convergido. Se puede generalizar dicha definici칩n al caso en que al menos un
$\beta \%$ de los individuos de la poblaci칩n hayan convergido. 

El esqueleto de este algoritmo es la base de la mayor칤a de las aplicaciones de los algoritmos gen칠ticos. Se podr칤a profundizar mucho m치s 
en detalles sobre cuales deben ser las diferentes probabilidades, tama침o de la poblaci칩n y n칰mero de generaciones. De esos detalles 
depender치, en gran parte, el 칠xito o fracaso de nuestro algoritmo.



\section{Modelo MapReduce}


Durante a침os, los programadores se han visto forzados a realizar implementaciones espec칤ficas para trabajar con grandes 
vol칰menes de datos en sus entornos distribuidos de trabajo.

Pese a que no siempre es necesario, el tama침o de la informaci칩n entrante suele ser grande y los c치lculos deben ser distribuidos 
entre una gran multitud de m치quinas para acabar en un tiempo razonable. Los problemas de c칩mo paralelizar estos c치lculos, 
distribuir la informaci칩n y manejar los fallos dificultan basatante la labor de implementaci칩n. 

El modelo de programaci칩n MapReduce es una propuesta que pretende resolver las dificultades anteriores, ya que sus caracter칤sticas 
y motivaci칩n se basan en la delegaci칩n de los c칩mputos intensivos en datos a un cl칰ster de m치quinas remotas que,
mediante un sistema de ficheros distribuido, repartir치n la carga de trabajo, optimizando tiempo y recursos. 
Asimismo, facilita un patr칩n de desarrollo paralelo para simplificar la implementaci칩n de aplicaciones intensivas en 
datos en entornos distribuidos. Este modelo puede dividir un espacio grande de problema en espacios peque침os y paralelizar 
la ejecuci칩n de tareas m치s peque침as en estos sub-espacios. 

Este modelo ha cobrado especial inter칠s por su aplicabilidad en entornos de Cloud Computing \cite{Web08}. 
MapReduce ofrece unas ventajas muy directas y evidentes como es la centralizaci칩n de los datos en servidores remotos, 
eliminando las dependencias con los soportes f칤sicos; o la contrataci칩n de servicios en funci칩n de las
necesidades de las empresas, sin tener que a침adir equipos, software o personal, lo que conlleva un considerable ahorro 
tambi칠n en el plano energ칠tico. 

Este cap칤tulo se estructura en varias secciones. En la primera de ellas se introduce el modelo MapReduce, desarrollando sus
dos primitivas fundamentales: map y reduce. En siguientes secciones se ir치n analizando las distintas implementaciones y 
ejemplos de uso, as칤 como una visi칩n general de Amaz칩n Elastic MapReduce, la implementaci칩n de este paradigma por parte de
Amazon.

\section{Introducci칩n}

MapReduce \cite{Dea08} es un modelo de programaci칩n, desarrollado por Google, que es utilizado para procesar grandes conjuntos de 
datos distribuidos a lo largo de un cl칰ster de servidores. Este procesado computacional puede tener lugar tanto sobre datos
almacenados en sistemas de ficheros, como en bases de datos. El modelo de programaci칩n est치 inspirado en los lenguajes funcionales 
y permite al desarrollador expresar sus algoritmos utilizando 칰nicamente dos funciones, \textbf{map} y \textbf{reduce}. 

Las funciones map y reduce de MapReduce se definen sobre datos estructurados en pares clave-valor. La funci칩n map, escrita por el 
usuario, recibe un par clave-valor y devuelve un conjunto de pares clave-valor intermedio:

%\begin{equation}
%	map: (k1 , v1) \xrightarrow{} [(k2 , v2)] 
%  \label{EcuacionMap}
%\end{equation}


Esta funci칩n (\ref{EcuacionMap})  se aplica en paralelo a cada par del conjunto de datos de entrada produciendo una lista de 
pares $(k2, v2)$ por cada llamada. MapReduce agrupa todos los valores intermedios asociados con la misma clave k y se los 
pasa a la funci칩n reduce.

La funci칩n reduce (\ref{EcuacionReduce}) recibe dicha clave y su conjunto de valores asociados y los fusiona para formar un conjunto 
de valores m치s peque침o:


%\begin{equation}
%	reduce: (k2 , [v2]) \xrightarrow{} [v3]
%	\label{EcuacionReduce}
%\end{equation}


Cada llamada reduce produce bien una lista v3 o un valor vac칤o. Los resultados de las llamadas se recopilan en la lista de 
resultados buscada. 




Desde la perspectiva del flujo de datos, la ejecuci칩n de MapReduce consiste en M tareas map y R tareas reduce independientes. 
Generalmente, los resultados intermedios se particionan en R trozos para R tareas reduce. La Figura \ref{Figura20} muestra el 
flujo de datos de alto nivel de un trabajo MapReduce.



Los principales elementos de un flujo de trabajo MapReduce son los siguientes:

\begin{itemize}
 \item \textbf{Proceso que lee la entrada}: divide los datos de entrada en bloques, siendo asignados cada uno de estos bloques a la 
 funci칩n map correspondiente. Estos datos ser치n le칤dos de un almacenamiento estable y generar치 pares clave/valor. 
 Un ejemplo com칰n ser칤a la lectura de un directorio entero, y la devoluci칩n de un registro por cada l칤nea de cada fichero.

 \item \textbf{Funci칩n de mapeo} (map): Cada funci칩n map recibe una serie de pares clave-valor, los procesa individualmente, y 
 devuelve cero o m치s pares clave-valor de salida. Los tipos de datos de la entrada y la salida de la funci칩n map suele ser
distintos. Por ejemplo, si la aplicaci칩n realizase un conteo de palabras, la funci칩n map separar칤a la l칤nea en palabras y 
sacar칤a como resultado la palabra como clave y un 1 como valor.
 
 \item \textbf{Funci칩n de partici칩n}: Las salidas de cada uno de los nodos map son asignadas a un nodo reduce en concreto a 
 partir del resultado obtenido por la funci칩n ``partition'' de la aplicaci칩n. Esta funci칩n devuelve el 칤ndice del reduce buscado, 
 dada una clave y un n칰mero de nodo reduce. Una funci칩n t칤pica es hallar el valor hash de la clave y hacer m칩dulo del n칰mero 
 de nodo reduce.

 \item \textbf{Funci칩n de comparaci칩n}: La entrada de cada reduce se obtiene de la m치quina en la que se ejecut칩 y orden칩 el 
 map utilizando la funci칩n de comparaci칩n de la aplicaci칩n.

 \item \textbf{Funci칩n de escritura de salida}: Escribe la salida de la funci칩n reduce en un almacenamiento estable, t칤picamente 
 un sistema de ficheros distribuido.
 
\end{itemize}

El principal beneficio de este modelo de programaci칩n es la simplicidad. El programador simplemente proporciona una descripci칩n 
del algoritmo centrada en su funcionalidad.





\section{Experimentos}

\section{Conclusiones y trabajo futuro}
\label{sec:conc}




El Cloud Computing ha llegado con mucha fuerza y todo hace indicar que viene para quedarse.  Hemos visto durante, 
la primera parte que son muchas m치s las ventajas que nos ofrece este modelo que los inconvenientes a los que nos podemos 
enfrentar.  

Todo proveedor de computaci칩n en la nube, nos ofrece una infraestructura que, a no ser que estemos en una gran empresa o 
seamos poseedores de superordenadores, no est치 a nuestro alcance y ello nos hace que instant치neamente podamos acceder 
a esos recursos y hacer uso de ellos de una forma r치pida, sencilla y con un coste bajo.  Precisamente esta posibilidad hace que 
sea una tecnolog칤a verdaderamente interesante para el mundo cient칤fico e investigador, pues habitualmente en tareas como 
an치lisis financiero, meteorol칩gico o bioinform치tica, entre otras muchas cosas, se trabaja con ingentes cantidades de datos 
que requieren de millones de c치lculos en poco tiempo y precisan de mucho tiempo, pese a tener grandes centros de datos. 

Por ello en este trabajo se ha propuesto un peque침o estudio dentro del gran mundo que es la bioinform치tica, utilizando 
la infraestructura de Amazon, el mayor proveedor de Cloud Computing y mucho m치s configurable que Google App Engine,
para la ejecuci칩n y an치lisis de algoritmos gen칠ticos b치sicos.  

Se ha implementado una peque침a librer칤a para el dise침o de algoritmos gen칠ticos de forma secuencial y un completo manual para 
la ejecuci칩n de estos algoritmos en los servicios web de Amazon.  Las caracter칤sticas m치s importantes de esta propuesta han sido:

\begin{itemize}
 \item \textbf{Extensibilidad:} Desde el primer momento de desarrollo se ha pretendido dotar a la librer칤a de un car치cter extensible, 
 abstrayendo todo lo posible los distintos elementos dentro de un AG con el uso de interfaces, herencia y dem치s 
 ventajas de un lenguaje como Java y facilitando el prototipado r치pido de AGs  mediante la implementaci칩n de un n칰mero m칤nimo de 
 funciones.

 \item \textbf{Portabilidad}: La aplicaci칩n se encapsula en un fichero JAR que puede ser ejecutado en cualquier entorno anfitri칩n que 
 disponga de un compilador Java, independientemente de su sistema operativo. Esto se ha hecho as칤, porque el objetivo principal e
 era ver las ventajas de computaci칩n en la nube, y lo mejor era un sistema portable entre distintas instancias vol치tiles en 
 Amazon EC2.

 \item \textbf{Sencillez}: El objetivo principal del trabajo, era conocer un poco m치s distintas posibilidades de servicios de la 
 nube de Amazon y como facilita el an치lisis de datos  y no profundizar mucho en Algoritmos Gen칠ticos, por esta raz칩n se han 
 implementado tres funciones sencillas. El 칰nico conocimiento necesario para realizar las pruebas viene explicado detalladamente 
 en el documento adjunto o la documentaci칩n generada por cada proyecto.
 
 \item \textbf{Aprendizaje}: Este trabajo es v치lido tanto como para alguien quiera iniciarse en el conocimiento de los algoritmos 
 gen칠ticos, como para alguien que quiere sentar las bases de Cloud Computing tener acceso a instancias virtuales en Amazon.
 
\end{itemize}


Una vez vistos hecho el an치lisis de los resultados de la versi칩n secuencial surgi칩 la posibilidad de buscar una alterantiva  
paralela para un algoritmo gen칠tico  e investigando se encontr칩 la posibilidad de  usar MapReduce, por ello, se ha descrito 
te칩ricamente en que consiste este modelo y en concreto, la implementaci칩n por parte de  Hadoop, que es la 
m치s conocida. 


Para introducirnos en el mundo de Hadoop, se ha explicado como hacer una configuraci칩n pseudo-distribuida en nuestro pc para 
comenzar a escribir aplicaciones de este tipo. Como primer ejemplo de ello, se ha propuesto y explicado la 
implementaci칩n de un b치sico contador de frecuencias de palabras en un conjunto de archivos, 
que pese a ser sencillo, nos da una muestra del potencial de MapReduce y de la sencillez de su implementaci칩n.  


Como extensi칩n se ha presentado una aproximaci칩n a un sistema capaz de adaptar la naturaleza intensiva en datos del modelo MapReduce con el car치cter 
iterativo de un Algoritmo Gen칠tico, sentando las bases para construir un software que permita ejecutar de forma distribuida 
algoritmos gen칠ticos paralelos tanto sobre cl칰sters, como sobre el servicio que nos proporciona Amazon Elastic MapReduce.  


En l칤neas generales, se ha descrito el dise침o y la implementaci칩n de AGs b치sicos tanto de forma secuencial  como paralela utilizando 
entornos secuenciales y de cloud computing con Amazon como proveedor, y se ha introducido al uso del Framework de Hadoop para el 
dise침o de aplicaciones con MapReduce.


Por 칰ltimo, destacar que las pruebas realizadas con la bater칤a de problemas elegida (``Rastrigin'', ``OneMAX'' y ``Marea'') arrojan 
resultados satisfactorios en cuanto a escalabilidad y tiempo, teniendo en cuenta adem치s que nuestra computadora desde la que 
mandamos los trabajos no consume recurso alguno. 


\section*{Futuras l칤neas de trabajo}


Hasta el momento solo ha podido desarrollarse un modelo de c칩mo ser칤a la implementaci칩n de un algoritmo gen칠tico paralelo 
usando MapReduce.  La principal l칤nea de trabajo ser칤a terminar la implementaci칩n de este modelo y hacer extensible 
las clases implementadas para la parte secuencial a la parte paralela.

Dentro de la l칤nea seguida en el proyecto podemos contemplar otras alternativas que completar칤an el estudio del modelo de 
programaci칩n MapReduce:

\begin{itemize}
 \item Se podr칤a investigar si compensa la generaci칩n inicial de individuos con una tarea MapReduce como propone \cite{Gen09}. 
Esto ser칤a 칰til para utilizar poblaciones de gran tama침o ya que en este caso, tendr칤a un costo inicial muy alto para el 
nodo maestro mientras los otros se encontrar칤an ociosos.
 \item Otro aspecto que podr칤a ser estudiado es la definici칩n de una clase personalizada InputFormat (la encargada de describir la 
especificaci칩n de los datos de entrada de un trabajo MapReduce) para poder configurar el n칰mero de tareas map a gusto del usuario.
\end{itemize}

En lo que engloba al Cloud Computing, hay varias opciones que me gustar칤a llevar a cabo:

\begin{itemize}
 \item Mover una aplicaci칩n a la nube, migrar sus datos, configurar una  instancia para que no sea vol치til, contratando una ip est치tica  y que 
 칠sta act칰e como servidor, y montar una p치gina web en ella. 
 \item Utilizar proveedores PaaS, como Windows Azure o Google App Engine para desarrollar un servicio en la web. 
\end{itemize}


En conclusi칩n, pr치cticamente para cualquier cosa en Internet se puede usar el Cloud Computing o aprovecharse de 칠l, s칩lo se ha visto 
una peque침a parte, pero hay mucha luz detr치s de las nubes.


% Eh.. un poco escaso, 쯡o?
\bibliographystyle{splncs}
\bibliography{cloudproject}
\end{document}
