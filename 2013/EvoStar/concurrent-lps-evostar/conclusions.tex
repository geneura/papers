
This work shows the simplicity of the implementation  of a hybrid
parallel genetic algorithm in functional-concurrent languages. The
executions units were mapped to built-in concurrent concepts of languages
(actors and agents) and the procedural to functions or methods. 

Erlang and Clojure are languages that encourage a \emph{zero mutable
  state}-\emph{all functional} programming style with advantages in
the design an correction of the algorithms, The protocols of Clojure
allow the principles of OO without the complications of inheritance;
its concurrent concepts  are specialized and flexible at the same
time. The Scala language is multi-paradigm and hybrid in relation with
the computation modes supported. When a shared data structure is
needed this language allows a more direct access and that could be an
advantage, although this has not been shown in our experiments through
the scaling capability. 

Among the new trends in pGAs are new parallel platforms, the new
languages with concurrent abstractions build-in are parallel platforms
too, and their use for develop pGAs can be a very good approach for
new GA developments. In the pGA model used in this work the chosen GA
architecture are concurrent-rich but the implementation remains simple
thanks of the high level of abstraction of the implementation
technologies. This paper is a proof of concept on how to map EAs to
these architectures, but at the same time show the strength and
weaknesses of each implementation. Generally speaking, Java based
languages such as Clojure and Scala are faster that Erlang running its
own virtual machine, but Erlang shows superior scalability which, in
certain scenarios, could mean that it could achieve better solutions
than the other two. 

We have also tested the scalability of the implementations in a
pool-based implementation, which shows the limitations of such
architectures; however, no attempt has been made to optimize it so the
only qualitative conclusion we can draw is that Erlang shows the best
scalability; that only one reproducer offers better results than two
in all cases, and that a good thing about these languages is that
performance does not suffer, but degrades gracefully, when many
threads are running at the same time. 

Our experiments shows Scala's performance like the best and point to Erlang like an very scalable runtime, the recommendations are to enrich the experiments with more complex case of study and to test the libraries in heterogeneous hardware in order to check scalability of each language.
