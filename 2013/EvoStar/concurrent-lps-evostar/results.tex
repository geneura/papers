
All languages used have functional and concurrent features built-in, with the first ones supporting the second ones. Erlang and Scala’s implementations are based in the actor pattern for doing parallel computation. Clojure’s in the other hand works with the agent concept, a similar model with simplify ways of read the information involved.

To communicate modules was used language’s dependent (different) data types. The message’s structure was tuples for Erlang and Scala, and for agents it was necessary encapsulate functions on protocols (Clojure variants of Java’s interfaces). For sharing individuals (the pool) was used functionals consult/modification data structures: hash-like for Scala/Clojure and the {\em ets} module in Erlang’s case. The data was encoded with compound data strucures : lists, vectors, tuples, records, etc. The Table \ref{tb:res:comp} summarize the differences between the languages.

\begin{table}
  \caption{Language's comparisons.}\label{tb:res:comp}
  \centering
  \begin{tabular}{|p{4cm}|>{\centering}p{3cm}|>{\centering}p{3cm}|>{\centering}p{3cm}|}
    \hline
     & \textbf{Erlang} & \textbf{Scala} & \textbf{Clojure} \tabularnewline
    \hline
    Parallel executing unit & actor & actor & agent \tabularnewline
    \hline
    Communication (messages) & tuple & tuple & function (protocol) \tabularnewline
    \hline
    pool & \texttt{ets} & HashMap & hash-map \tabularnewline
    \hline
    DS chromosome & list & list & vector \tabularnewline
    \hline
    DS population & list & list & lazzy list \tabularnewline
    \hline
    Compound data & tupla & tupla/objeto & record/vector \tabularnewline
    \hline
    Runtime environment & Erlang VM& Java VM& Java VM \tabularnewline
    \hline
  \end{tabular}

\end{table}

%\subsection{Resultados numéricos}\label{resNum}

%El diseño fue puesto a prueba con cromosomas de longitud 100, una población de 1024 individuos por isla (usándose 2 islas) y con 25 evaluadores y 10 reproductores trabajando con bloques de 50 cromosomas. Los experimentos fueron realizados en un ordenador portátil con Windows 8, 16 GB de RAM y un procesador Core i7.
%
%Los resultados obtenidos aparecen a continuación, en la Tabla \ref{tb:resFitness}, correspondiendo a evaluaciones independientes promediadas cuya condición de parada es la obtención de un fitness de 395. Los resultados de las ejecuciones (promedios) usando como condición de parada la ejecución de 5000 evaluaciones aparecen en la Tabla \ref{tb:resEvaluations}.
%
%\begin{table}
%  \caption{Resultados de los experimentos por fitness.}\label{tb:resFitness}
%  \centering
%\begin{tabular}{
%|>{\centering}p{1.6cm}|>{\centering}p{2cm}|
%>{\centering}p{2.55cm}|>{\centering}p{2.5cm}|}
%  \hline
%  \textbf{Lenguaje} & \textbf{Migraciones} & \textbf{Evaluaciones} & \textbf{Tiempo (ms)} \tabularnewline
%  \hline
%  \input{resFitness}
%\end{tabular}
%\end{table}
%
%\begin{table}
%  \caption{Resultados de los experimentos por cantidad de evaluaciones.}\label{tb:resEvaluations}
%  \centering
%\begin{tabular}{
%|>{\centering}p{1.6cm}|>{\centering}p{2cm}|>{\centering}p{2.5cm}|}
%  \hline
%  \textbf{Lenguaje} & \textbf{Migraciones} &
%  \textbf{Tiempo (ms)} \tabularnewline
%  \hline
%  \input{resEvaluations}
%\end{tabular}
%\end{table}
%
%Con el objetivo de hacer un análisis de speedup\footnote{En su traducción \emph{aceleración}, medida de la ganancia en velocidad al usar más procesadores.} acorde lo expuesto en \cite{Alba02parallelevolutionary}
%%o de \cite{Barr1993}
%se hizo también una implementación secuencial usando las mismas estructuras de datos e implementaciones de operadores. Por speedup entenderemos la razón entre $E[T_1]$ (promedio de tiempos de ejecución de la implementación secuencial) y $E[T_m]$ (promedio de tiempos de ejecución de la implementación paralela en $m$ procesadores), teniendo presente que en la arquitectura diseñada se encuentra hecha una paralelización de fases del algoritmo por lo que se realiza mucha más comunicación (con el correspondiente recargo) que la ocurrida en el caso descrito en \cite{Alba02parallelevolutionary}.
%
%En las tablas \ref{tb:resSpeedupFitness} y \ref{tb:resSpeedupEvaluations} mostradas a continuación aparecen los resultados de speedup para nuestro caso
%(70 % OJO, cambiar si cambiamos el experimento
%unidades de ejecución en el caso paralelo).
%
%\begin{table}
%  \caption{Speedup de los experimentos con parada por valor de fitness.}\label{tb:resSpeedupFitness}
%  \centering
%
%\begin{tabular}{|>{\centering}p{1.6cm}|>{\centering}p{1.5cm}|>{\centering}p{1.5cm}|>{\centering}p{1.5cm}|}
%  \hline
%   & \textbf{$E[T_1]$} & \textbf{$E[T_m]$} &  \textbf{speedup} \tabularnewline
%  \hline
%  \input{resSpeedupFitness}
%\end{tabular}
%
%\end{table}
%
%\begin{table}
%  \caption{Speedup de los experimentos con parada por cantidad de evaluaciones.}\label{tb:resSpeedupEvaluations}
%  \centering
%
%\begin{tabular}{|>{\centering}p{1.6cm}|>{\centering}p{1.5cm}|>{\centering}p{1.5cm}|>{\centering}p{1.5cm}|}
%  \hline
%   & \textbf{$E[T_1]$} & \textbf{$E[T_m]$} &  \textbf{speedup} \tabularnewline
%  \hline
%  \input{resSpeedupEvaluations}
%\end{tabular}
%
%\end{table}


