
We developed a library in Scala following the same design concepts and it was test with the case study. The code is open, under AGPL license, at \url{https://github.com/jalbertcruz/sclEA/tree/evostar2014}. The main classes and objects are briefly described.

\subsubsection{Evaluator/Reproducer's classes}

The reproducer class select the subpopulation and parents for reproduction, it does the crossover and activate migrations. As actor respond to {\em evolve} and {\em emigrateBest} messages, for iteration and migration operations.

Class {\em Evaluator} consults the pool constantly looking for no-evaluated individuals. It is compound by the function {\em evaluate/1} (general evaluation function), and the message: {\em evaluate} for fire the calculation.

These two kinds of actors are the executing units working for reach the solutions. They have in the architecture the same role than Erlang’s actors, with the same behavior but in an object oriented way.
%
%\subsubsection{PoolManager and auxiliary classes}
%
%The {\em PoolManager} class initialize the pool’s workers (evaluators and reproducers) and decide the message’s routes among them. Besides these classes it's used some objects and support clases:
%
%\vspace{.35cm}
%
%\begin{description}
%
%  \item[Objets ExperimentRun and Experiment] -- Experiments initialization and execution.
%
%  \item[Profiler class] -- Execution statistics: execution time, number of iterations, etc.
%
%  \item[IslandManager class] -- Pools coordination, start and finalization controls.
%
%  \item[Manager class] -- Multi-experiments control and final report emission.
%
%\end{description}
