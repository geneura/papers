\documentclass{sig-alternate}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{cite}
\usepackage{url}

\usepackage{url}

\hyphenation{NIndexes}

\begin{document}

\title{Adapting evolutionary algorithms to the concurrent functional language Erlang}

\numberofauthors{2}
 \author{
 \alignauthor
 J. Albert Cruz\\
        \affaddr{Centro de Arquitecturas Empresariales}\\
        \affaddr{Universidad de Ciencias Inform\'aticas}\\
        \affaddr{La Habana, Cuba}\\
        \email{jalbert@uci.cu}
 \alignauthor
 Juan-J. Merelo, Antonio M. Mora and Paloma de las Cuevas\\
 \affaddr{Departamento de Arquitectura y Tecnolog\'ia de Computadores}\\
 \affaddr{Universidad de Granada}\\
 \affaddr{Granada, Spain}\\
 \email{\{jmerelo,amorag,paloma\}@geneura.ugr.es}
 }

\maketitle
\begin{abstract}
In this paper we describe how the usual sequential and procedural
Evolutionary Algorithm is mapped to a concurrent and functional
framework using the Erlang language. The design decisions, as well as
some early results, are shown.
\end{abstract}

% A category with the (minimum) three required fields
\category{D.1.3}{Software}{Programming Techniques}[Concurrent Programming]
\category{D.2.8}{Software Engineering}{Performance measures}
%A category including the fourth, optional field follows...
\category{G.1.6}{Mathematics of Computing}{Numerical Analysis}[Optimization]

% Antonio - A ver si te mola esta categoría también:
%D.2.8 [Software Engineering]: Metrics—complexity mea-
%sures, performance measures
\terms{Algorithms, Languages, Performance, Measurement}
% Antonio - no se si se puede añadir algún otro término (Theory?)

\keywords{Evolutionary Algorithms, Functional Languages, Concurrent Languages, Erlang, Algorithm Implementation}

\section{Introduction and state of the art}

%Evolutionary Computation (EC) is an effective method for improving, and therefore optimizing, behaviours that lead to a better use of available resources.
% Antonio - he puesto Evolutionary Computation, ya que Evolution es muy genérico
% Eso sí, es un comienzo un tanto raro, a qué te refieres con los recursos disponibles. La optimización se refiere a muchos ámbitos, no sólo a un mejor uso de los recursos... ;)
% JA - El sentido de "available resources" es: lo que tengo, sea el parámetro que sea, y quiero usar de mejor(subjetivo, lo que el usuario entienda) manera
% Yo quitaría esta frase - JJ
%This scientific field is very active producing libraries of diverse quality and applying it to many domains.
% Antonio - falta una frase para conectar esta con la anterior. Pasar de hablar de EC a decir que para eso (para optimizar usando EC) los científicos han hecho librerías... mejor decir que el campo de la EC es uno de los más prolíficos en la creación de librerías, etc, etc...
The Evolutionary Computation (EC) field  is  focused on the use widespread implementation technologies such as C/C++, Fortran and Java.
Getting out of that mainstream it is not normally seen as a land for scientific improvements.
% Getting out of that mainstream it is not normally seen a land for improvement science.
% Antonio - Esta frase casi no se entiende. La intento reescribir a ver si dice lo que tú querías.
% Y yo la vuelvo a reescribir. - JJ
One such language with a big potential is Erlang, which is an implementation technology that supports the functional and concurrent paradigms and that is starting to be used in the scientific community \cite{Sher2013}. 
% Antonio - haz una breve inroduccióna Erlang aquí y dí si se usa o no en la comunidad científica. Pon alguna cita. ;)
% afú, qué inglés... - JJ

In this paper we propose to apply this language (and underlying paradigm) to Genetic Algorithms (GA) \cite{GA_Goldberg89},
% Antonio -  Pongo una cita a GAs
which are general function optimizers that encode a potential solution
to a specific problem in a simple data structure (a chromosome). There
are only two components of them that are problem dependent: the
solution encoding and the function that evaluate the quality of a
solution, i.e., the fitness function. The rest of the algorithm does
not depend on the problem and could be implemented following the best
architecture and engineering practices.

Many such practices have been proposed in the object oriented paradigm
\cite{EO:FEA2000}, but that is not the case of the functional
side. This work tries to show some possible areas of improvement on
that sense by focusing on GAs as a domain of application and
describing how their principal traits can the be modeled by means of
Erlang constructs. This will be done in the next section. 

% Antonio - cuenta en un par de líneas qué es Erlang. ;)

%Other concurrent oriented languages such as Ada \cite{Santos2002} has been reported as a feasible technology for implement this kind of algorithms.
% Antonio - esto no lo digas si no lo vas a extender un poco. Queda como una frase 'huérfana'. ;)
% Dí por ejemplo qué desventajas tiene respecto a Erlang...


% Actualizar esto
% Antonio - sí, revísalo porque ya no hay sección de resultados
% The rest of the paper is organized as follows: next section
% presents considerations around the functional paradigm and its conceptual relation with evolutionary computation; we will explain then the general characteristics of a pool based concurrent evolutionary evolutionary used as use case in this work. Results and conclusions obtained will be presented in Section \ref{sec:conclusions}.


\section{Evolutionary algorithm in a concurrent functional language}
\label{sec:evo}

A variety of programming patterns, i.e., paradigms, exist for implementing the algorithms models. GAs are characterized by an intensive use of strings
% Antonio - he puesto GAs porque es lo qu ehas comentado en la intro. ;)
 (lists of some kind) for encoding genes and a population that evolves
 via operators that are applied to all or a part or it. Most modern
 languages can handle these data structures (and the operators needed
 to manipulate them).
%A programming language whose characteristics fit these needs would be
%highly appreciated. Ya hay un montón de lenguajes que hacen eso..

%\subsection{Erlang description}
% Antonio - ¿description?

There is a claim in modern software development for programming languages that help with concurrent programming and simplify coding practice.
% Antonio - qué quiere decir better abstraction? acláralo. :D
The functional programming language Erlang would be an answer that provides the actor pattern concept for concurrency and the functional paradigm for general modeling, design and coding of solutions.
% Antonio - este texto parece de publicidad de Erlang, jeje.
%
Actors are concurrent execution units which use asynchronous message passing for communication. They are implemented as processes in the Erlang's virtual machine
% Antonio - no has comentado qué es la VM. No has dicho que se implementa sobre Java...
 and not as operating system (OS) threads, which means that they are very
 lightweight in creation and execution.
% Antonio - ¿qué quiere decir que sean ligeros?
The use of messages eliminates the sharing of state and
% Antonio - dí qué son mensajes inmutables
eliminate many of the typical problems of concurrent development,
namely, supporting the emulation of the Object Oriented (OO) paradigm
with its modeling facilities. 

Functional programming, the other main feature of the Erlang language, is defined by the use of functions in program composition and by using lists.
% Antonio - Esta frase no se entiende bien y está mal escrita. ;)
Erlang honored the functional linage and includes ultra fast technologies for persist data called Dets and Mnesia. % que sirven para... - JJ
% ¿las usas aquí? ¿Pueden ser útiles? - JJ 
% si no lo son podrías borrarlo. Y, por favor, comprueba la corrección
% gramatical de número - JJ
Besides, Erlang offers the concept of records for group data which helps to modularize the code. % y esto es útil porque... -JJ
% No me has contestado a esto...

%\subsection{Genetic Algorithm mapping to Erlang}

Genetic algorithms, as many other computational models, tend to be
described in literature in an operational and imperative way. Their
implementation in a functional language must follow a different path,
structuring the algorithm model in less imperative and more
declarative terms. We are going to use a parallel pool based
evolutionary strategy (which was already used for instance in \cite{DBLP:conf/3pgcic/GuervosMFEL12}) as use case. % ¿nuestra media? - JJ

The pool will be an execution entity (an actor acting like a server) that will own the population and also keep a track of the advance in the solution search. The clients, which are concurrent, will do the calculations and will join and leave the system at any time without consequences. Chromosomes will be encoded as lists and the different parts of the GA algorithm will be implemented as Erlang functions.
% Antonio - functions -> actors?

An Erlang actor is implemented by a sequence of pairs
pattern/expression defining each message that it could handle. It is
close to the OO parlance and a way to organize the code. In this case
we use one message per service that pool must provide; Table
\ref{poolTable} presents this.
%Antonio: no le has protestado porque ha puesto Table en minúsculas - JJ
%
\begin{table}
  \centering
   \begin{tabular}{|p{3.2cm}|p{3.8cm}|}
   \hline
   \textbf{Message} & \textbf{Description}\\
     \hline
{\tt \{configPool, NIM\} ->} & Initialization, the parameter NIM is the initial configuration. \\
\hline
{\tt \{requestWork, Pid, Capacity\} -> } & Client requests for a population to evolve.\\
\hline
{\tt \{generationEnd, NewIndividuals, OldIndexes, Pid\} ->}& One client report its successfully end of calculation. \\
\hline
   \end{tabular}
  \caption{The messages that the pool accepts.}\label{poolTable}
\end{table}
%
Clients are modeled by actors. They are the units of evolution, with the main computation responsibilities; the Table \ref{clientTable} shows its interface.

\begin{table}
  \centering
   \begin{tabular}{|p{3cm}|p{4cm}|}
   \hline
   \textbf{Message} & \textbf{Description}\\
     \hline
{\tt initEvolution -> } & Marks the beginning of the processing. \\
\hline
{\tt \{evolve, P, NIndexes\} -> } & When the pool could assign a subpopulation to process. \\
\hline
\end{tabular}
  \caption{The messages a client is able to respond.}\label{clientTable}
\end{table}

%\subsection{Generality and configuration}
% No hace falta tantas subdivisiones en un artículo de dos páginas, caray... eliminar todas las sub y subsubsecciones - JJ
% Al dejar solamente secciones ha quedado un poco raro, digo yo, nada vean ahora y quítenlas si se debe..
% Las voy a quitar porque además falta espacio

The two previous components constitute the main features of the
architecture of the algorithm; they are general-purpose and could be
used for many problems. % Many problems qué? - JJ
 In order to solve a particular situation, they must be
 \emph{injected} by several functions and data structures which define
 chromosomes, fitness function, mutation operator, selection criteria
 and replacement policy. All these particularizations must be
 implemented in an Erlang source file and configured in the
 \emph{configBuilder} module. % ¿Esto es general a todos los programas
                              % en Erlang? - JJ

The proposed design promotes a clear separation between architecture
(the general, constant and paradigmatic foundation part) and problem
encoding (the representation and criteria of solution finding) which
is good for applying the library to solve another problem.  %Lo has
                                %explicado en parte, pero no del
                                %todo. ¿Por qué habría que querer
                                %hacerlo así? ¿Vas a implementar otros
                                %tipos de algoritmos genéticos?
                                %¿Podría servir para cualquier
                                %algoritmo basado en población?
This design has been implemented and tested with a simple benchmark
problem. This will be presented in the next section. 

\section{Experiment and conclusions}
\label{sec:conclusions}

In this ongoing project we are testing the efficiency and simplicity of implementations of GAs by functional programming. The parallel models of GA are mapped to actors in the Erlang languages obtaining easily to understand architectures. All the code has been released as open source code at \url{https://github.com/jalbertcruz/erlEA/}.

The library was tested with \emph{MaxOnes} problem. The chromosomes
was 128 elements long, with an initial population of 256
individuals. 50 clients were used and they worked with 20 individuals
each time a pool assigned a generation to them. The solution, an
optimum, was reached after 3159 assignments in 3.144590 seconds. For
100 clients the solution was reached in 6.121570 seconds and 6446
assignments; and for 25 clients it was 1835 assignments in 1.687000
seconds. This results shows that in this case there it is not
convenient to use many clients in order to obtain the solution, when
the number of clients increase there is a lot of bad solutions evaluated. 
% Esto deberías haberlo puesto en una tabla. Pero el problema
% principal es que la solución es bastante mala. ¿Seguro que el
% algoritmo genético va bien? ¿Seguro que los actores funcionan de
% forma concurrente o ocupan todos el mismo proceso y se ejecutan de
% forma secuencial? - JJ

With this concept test we are showing how simple is to structure a parallel GA, now we could proceed with more complex GA models, experiments and problems in order to explore the potential of the technology.

\section*{Acknowledgements}

This work is supported by project TIN2011-28627-C04-02 (ANYSELF),
awarded by the Spanish Mineco and P08-TIC-03903 awarded by the
Andalusian Regional Government. It is also supported too by the PhD
Program of the AUIP and by project 83, Campus CEI BioTIC.

\nocite{*}
\bibliographystyle{abbrv}
\bibliography{concurrent}
\balancecolumns

\end{document}
