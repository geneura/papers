
\noindent El campo de la Computación Evolutiva (CE) es rico en características, modelos y problemas pero no lo es igual en cuanto a paradigmas de programación a usar en la implementación de los algoritmos. Tecnologías como Java, C/C++ y Perl se mantienen como las más usadas y aunque se acepta la importancia de la implementación \cite{DBLP:conf/iwann/MereloRACML11}, no es mucho el interés de la comunidad científica en abordar nuevos lenguajes de programación por novedosos y prometedores que pudieran ser.

Dos paradigmas emergen actualmente en la industria del software como herramientas de abstracción ante viejos y nuevos problemas: el funcional y el concurrente. Aunque los lenguajes funcionales están a la mano desde hace buen tiempo (LISP es uno de los lenguajes de programación más longevos que existe) nunca han sido de mucho uso fundamentalmente por no disponerse de implementaciones eficientes. Esto ha ido cambiando, sus desventajas superándose y las ventajas llevando a que varios de sus conceptos sean incluidos en lenguajes modernos (ejemplo C\#).

El desafío de los multi-núcleos \cite{SutterL05}, entendiéndolo como la necesidad de hacer paralelo el más simple de nuestros programas de manera que hagan uso de los modernos y potentes microprocesadores, lleva a crear (o retomar), patrones para el desarrollo de algoritmos paralelos. Dentro de dichos patrones algunos acaban como nuevas características en lenguajes de programación existentes y otros sirven como principio de diseño para lenguajes completamente nuevos. Entre los lenguajes emergentes con soporte al paradigma concurrente destacan Clojure, Go, Scala, Haskell y Erlang; en todos existen construcciones para manejar la concurrencia: facilitando razonar sobre ella y simplificando su sintaxis. El presente trabajo se encarga de explorar la idoneidad del lenguaje Erlang para la implementación de Algoritmos Genéticos Paralelos y pudiera servir como motivación para hacer lo mismo con los demás lenguajes mencionados.

%El resto del trabajo se estructura como sigue: estado del arte, dentro del que se caracterizan los paradigmas funcional y concurrente y se describe el lenguaje Erlang que los incluye. A continuación se muestra la modelación e implementación de un algoritmo genético usando conceptos de los paradigmas antes expuestos (Sección \ref{sec:design}); y finalmente, en la Sección \ref{sec:conclusions}, se presentan los resultados y conclusiones.
