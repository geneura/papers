\documentclass{sig-alternate}
\usepackage[latin1]{inputenc}
\usepackage{url}
\usepackage{listings}

\begin{document}
%
% --- Author Metadata here ---
\conferenceinfo{GECCO'14} {Vancouver, Canada}
\CopyrightYear{2014}
%\CopyrightYear{2007} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\title{Assessing different architectures for evolutionary algorithms in JavaScript}
\subtitle{}

\author{
% \alignauthor
% J.J. Merelo, Pedro Castillo, Antonio Mora\\
%        \affaddr{University of Granada}\\
%        \affaddr{GeNeura, Department of Computer Architecture and Technology, ETSIIT + CITIC}\\
%        \affaddr{18071 - Granada}\\
%        \email{jmerelo,pedro,amorag@geneura.ugr.es}
% \alignauthor
% Anna I. Esparcia-Alc�zar\\
% \affaddr{S2 Grupo}\\
% \email{aesparcia@s2grupo.es}
% \alignauthor
% V�ctor Rivas-Santos\\
% \affaddr{Universidad de Ja�n}\\
% \email{vrivas@ujaen.es}
\alignauthor
Three wise guys\\
       \affaddr{University of Miskatonic}\\
       \affaddr{Wise affairs dep}\\
       \affaddr{Metropolis}\\
       \email{some.good.e@mails.com}
\alignauthor
Another author\\
\affaddr{Adrress}\\
\email{e@ma.il}
\alignauthor
Last one\\
\affaddr{Science Institute}\\
\email{last@o.ne}
}

\maketitle
\begin{abstract}After almost fifteen years, JavaScript has finally risen as a popular
language for implementing all kind of applications, from server-based
to rich Internet Applications. Its features are interesting for
implementing evolutionary algorithm frameworks 
% Maribel, y por qué? 
that encompass both
tiers, but, besides, they allow a change in paradigm that goes beyond
the canonical evolutionary algorithm. 
%Maribel, muchos frameworks van más allá del algoritmo genético canónico, pero esto no pasa porque estén hechos en javascript
In this paper we will experiment
with different architectures
% Maribel, ¿Cuales?, una arquitectura diferente no es un sistema operativo diferente 
implementations and evolutionary
algorithms to assess which ones offers most advantages in terms of
performance, scalability and ease of use 
% Maribel, lo de la facilidad de uso no hay forma de medirlo a no ser que sea tu propia intuición o experiencia y no vale a no ser que hayas usado otros lenguajes y otras herramientas
for the computer scientist. All implementations  have been released as open source.
\end{abstract}

% A category with the (minimum) three required fields
\category{H.4}{Information Systems Applications}{Miscellaneous}
%A category including the fourth, optional field follows...
\category{D.2.8}{Software Engineering}{Metrics}[complexity measures, performance measures]

\keywords{ACM proceedings, \LaTeX, text tagging}

\section{Introduction}

JavaScript was introduced in 1998 as a browser-oriented language by
Netscape \cite{flanagan1998javascript}; it was quickly adopted, in
several versions, by the rest of the existing browsers (Internet
Explorer, Opera and the offspring of Netscape, Mozilla and then
Firefox). It became a standard by the European Association for
Standardizing Information and Communication Systems in 1999
\cite{ecma1999262}. However, it was for a long time considered just a
language for the browser, and in fact most books on JS
\cite{goodman2007javascript} start by
telling you how to embed your scripts in the browser HTML code.

As such as a embedded language, Javascript is an interpreted language
that uses classes and objects, uses functions as first-rate types and
is dynamic and weakly typed-checked (a variable can chenge its type during
its lifetime, but whatever type it has needs to be explicitly coerced
to other type in some contexts, but not in all). These features make
it an ideal language for quick prototyping and productive
programming. 

However, the graduation of JS to a full-fledged language did not arrive until the first years of
this century with the introduction of command-line interpreters such
as SpiderMonkey or Rhino \cite{mikkonen2007using}, but it was not
until Google's introduction of the V8 \cite{richards2010analysis}
interpreter and its adoption by  {\tt node.js} that it started to
become what it is now, one of the most popular development languages
\cite{ogrady14:ranking}. At the same time, it is the only language of
which it can be said that it is truly ubiquituous; every
internet-connected device has at least one interpreter
\cite{crockford:javascript} (often as a browser) but you can find it
also as the language of choice of the Gnome user-interface in Linux,
CouchDB object database, in many Platform-as-a-service products such
as Heroku, Nodejitsu or Openshift. It can also be easily installed in
IaaS products such as Windows Azure or Amazon. That makes it the right
choice for parasitic-style or volunteer computing platforms such as
Crowdprocess. The fact that there are interpreters embeded in browsers
and in server-side services makes the only language in which you can
develop both the client and server tier of a client-server application
(and, for that matter, any other tier in between).

What we propose in this paper is to measure different ways of
implementing distributed evolutionary algorithms using Javascript. It
has already been proved that implementation matters
\cite{DBLP:conf/iwann/MereloRACML11}, and it does so since the
evolutionary framework must be translated to a particular language in
a way that goes with its grain and not in the way that is more easily
translated from C or Java, but also because it offers new ways of
implementing evolutionary algorithms. In many cases, the environments
where JavaScript excels, the browser, for instance, might need proper
support in the shape of evolutionary algorithms; finally, creating
distributed evolutionary algorithms is easy using JavaScript; so easy,
in fact, that there are so many ways of doing it and mixing and
matching them (WebSockets, Ajax and REST, just to name a few) that it
becomes necessary to give an initial idea of how to make them useful
for evolutionary algorithms and what is the performance we should
expect. 

The experiments proposed in this paper have been released under an
open source license and are available right now (address withheld for
anonymous review). They offer a glimpse into the different
possibilities of programming using Javascript, but at the same time
show the kind of performace we should expect from them and what it
wins from parallel oepration. In doing so, our intention is to prove
that the translation of the usual distributed evolutionary paradigm
into this new language is valid, but also which option offers the best
performance in terms of scalability and number of evaluations needed
to reach the solution.

The rest of the paper is organized as follows: next we describe the
state of the art in new and uncanny implementations of evolutionary algorithms and
past implementations using different JavaScript interpreters. The
algorithm that has been adapted to JS is described next along with the
experimental setup in Section \ref{sec:node}; finally results are presented and its implications
discussed in the last section of the paper. 

\section{State of the art}
\label{sec:soa}

Evolutionary algorithms have always been targeted by new programming
languages, with implmentations cutting across paradigms and computing
platforms; the relatively new language Clojure (which is 17th in the
RedMonks ranking), for instance, has been used to implement the PushGP
system (which uses its own language, Push) \cite{helmuth2013evolving};
Ruby (7th in the ranking) was used as the backoffice for a JavaScript
evoluitonary algorithm in the AGAJAJ system \cite{agajaj} but it
actually implements a evolutionary algorithm within a testing
framework called RuTeG \cite{mairhofer2011search} using this
language. In fact, this use has not been limited to new and
paradigm-heavy languages; Langdon used the venerable {\tt awk} to
handle populations of millions of regular expressions in
\cite{langdon2008evolving,langdon2009evolving} and claims:
\begin{quote}
Although this may seem complex, gawk (Unix' free interpreted pattern
scanning and processing language) can handle populations of a million
motifs. 
\end{quote}
This, in fact, proves that in many cases using new tools outside the
mainstream programming languages can lead to new insights on the
algorithm (in this case, the use of populations much bigger than is
usual in evlutionary algorithms) and, of course, faster and more
efficient solutions of the problem at hand. 

However, Javascript has not been the subject of extensive
experimentation until now. The first mention of JavaScript in relation
with evolutionary algorithms was in 1996, when Smith and Sugihara
\cite{smith1996ga} used it for creating the user interface of a
browser-based evolutionary building system that was, in fact, based in
Java. It was not much later, in 1998, when a single-browser
evolutionary algorithm for evolving the layout of a web newspaper was
published \cite{jj-ppsn98}. In this case a outstanding feature of
JavaScript, the fact that it is embedded in the browser, was used to
evolve the document object model in a native way; it could not have
been done in any other way since the intention was that a personalized
page was generated by every user and rendered using the user's own
computing power, without needing to overload the server witht he
generation of pages for thousands of users. In this sense it also
pointed out to {\em unwitting} \cite{klein2007unwitting} use of resources which was taken full
advantage later on for the generation of L-System (a grammar for
describing fractal objects) in a distributed way
\cite{langdon2004global} once again, and in the same way that has been
mentioned before, a proof of choosing the right language for the
evolutionary algorithm outside the mainstream languages.

The distributed capabilities of JavaScript were discovered later on
with the realization of the possibilities of Ajax for distributing
information mediated by a server. This was implemented in different
ways, \cite{gecco07:workshop:dcor,klein2007unwitting,agajaj}. These
initial experiments mainly revealed that the usual ways of
distributing evolutionary algorithms (farming out evaluation or using
synchronous islads) were not suitable to a ephemerous client that
could enter a particular experiment at any time. It was clear also
that new paradigms, based on using {\em pools} of resources and
dealing with them asymmetrically could also be better suited to this
environment that symmetric algorithms with uniform distribution of the
population of the algorithms. Several systems have recently been
tested with this permise
\cite{DBLP:conf/evoW/ValdezTVGO13,sofea:cec2012}. Although most of
them use JavaScript, those that do not use it (like EvoSpace,
\cite{DBLP:conf/evoW/ValdezTVGO13} reach conclusions that can be
applied to JS-based evolutionary algorithms as well.

The current state of the art shows that JS can, indeed, be used in a
cloud computing environment, but that an assessment of its performance
in different situations, frameworks and methodologies might be in
order. This is what we will cary out in this paper via different
implementations mainly done in the asynchronous JS interpreter {\tt
  node.js}.

\section{An evolutionary algorithm in {\tt node.js}}
\label{sec:node}

{\tt node.js} (which, from now on, we will simply call Node) is a JS
interpreter based on the V8 virtual machine created by Google. It is
designed to deal with asynchronous input/output by default and it
includes, by default, an event model that makes event-driven
programming extremely easy \cite{5617064}. Since it is essentially a
JS interpreter, sequential and synchronous programs are possible and,
due to the speed of the underlying JS virtual machine, have a high
performance, but the best way of using it is by taking advantage of
the asynchronous I/O features that make it different from other JS
interpreters such as SpiderMonkey or Rhino and, in fact, closer to the
event-driven programming that is usual in browsers.

From the point of view of parallel evolutionary algorithms, which will
have to do input/output operations to interact with the rest of the
islands, this
basically means that this pattern
\begin{lstlisting}
generate_population();
do {
  single_generation();
  if (time_to_migrate()) {
    migrate_out();
    migrate_in();
  }
} until evolution_end();
\end{lstlisting}
will not work as expected. The main problem is that all input/output
operations will create events in the implicit event loop, which will
generate callbacks once the request has been completed. Code shown
above will work, but will {\em never} have time to process the events
and thus migrations, either in or out, will never take place (or
rather, inbound requests will be made but not processed and outbound
requests will actually be made, but if the client on the other side
works in the same way, it will never be processed). So, instead of
this sequential loop, a long-lasting loop must be done this way in
Node \cite{nodejs:patterns}:
\begin{lstlisting}
generate_population();
do_evolution();

function do_evolution(){
  single_generation();
  if (time_to_migrate()) {
    migrate_out();
    migrate_in();
  }
  if ( !evolution_end() ) {
    do_after_callbacks( do_evolution());
  }
}
\end{lstlisting}

This is not only a way of writing the programs using different patterns,
it also a different way of understanding the program sequence. In a
synchronous framework, the first pseudo-code should be expected to behave
in this way:
\begin{lstlisting}
Generation 1
Generation 2
...
Generation 20
Migration-out
Migration-in
\end{lstlisting}

However, what we will find in an evolutionary algorithm in Node
programmed as above will be something like
\begin{lstlisting}
Generation 1
Generation 2
...
Generation 20
Request-Migration-out
Reguest-Migration-in
...
Generation 22
Migration-in taking place
...
Generation 27
Migration-out taking place
\end{lstlisting}
Asynchronous programming not only means that events will be happening
at an undeterminate time in the future, but also that they might take
place out of sequence; in fact the sequence might very well be
\begin{lstlisting}
Migration-in 2 taking place
...
Migration-out 0 taking place
...
Migration-in 1 taking place
\end{lstlisting}

When designing an evolutionary library that can be used in the browser
{\em and} in Node, however, one of the main things that must be taken
into account is that longish computational stretches must be divided
into more {\em atomic} chunks so that input-output events can happen
between them; however, this concerns mainly the design of library {\em
  clients}, not the library itself. Thus, an open source library for
Node has been released  so that it can be used with the Node package
manager, installed with it and used in any Node program (the name and
URL have been withheld for anonymous review).

The library has been intended mainly as a proof of concept, including
the bare minimum to run an evolutionary algorithm: a single mutation
and crossover operators, tournament selection and a few test
functions, including the Trap function, that has been selected for
making the experiments in this paper. 




%ACKNOWLEDGMENTS are optional
\section{Acknowledgments}

%Este trabajo se est� desarrollando gracias a la financiaci�n de  los
%proyectos CANUBE (CEI2013-P-14) y ANYSELF (TIN2011-28627-C04-02). 

%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{geneura,javascript,ror-js}  % sigproc.bib is the name of the Bibliography in this case

\end{document}
