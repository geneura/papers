\documentclass[runningheads]{llncs}
\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx,epsfig}
\usepackage{algorithmic}
\usepackage{listings}
\usepackage{rotating}
\usepackage{multirow}
\usepackage{subfigure}
\usepackage[boxed]{algorithm2e}

\providecommand{\SetAlgoLined}{\SetLine}
\providecommand{\DontPrintSemicolon}{\dontprintsemicolon}
%%%%

\usepackage{color}
\usepackage{alltt}
\usepackage{verbatim}
\usepackage{url}
\usepackage[latin1]{inputenc}
%\usepackage[spanish]{babel}

%%

\usepackage{url}
\urldef{\mailsa}\path|pablogarcia@ugr.es|

% ¿Cuál es el máximo? Si son 10 páginas, tienes que recortar - JJ FERGU: si, es que no tengo el pograma para girar la metodología aquí

\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\lstset{
basicstyle=\ttfamily, %\scriptsize, QUITAR LA COMA DE TTFAMILY SI DESCOMENTAS
language=c++,
frame=single,
stringstyle=\ttfamily,
showstringspaces=false
}



\newcommand\blfootnote[1]{%
  \begingroup
  \renewcommand\thefootnote{}\footnote{#1}%
  \addtocounter{footnote}{-1}%
  \endgroup
}



\begin{document}
\pagestyle{empty} %ESTO QUITA LOS NUMEROS DE PAGINA
\mainmatter  % start of an individual contribution



% first the title is needed
\title{A methodology to develop Service Oriented Evolutionary Algorithms}


% a short form should be given in case it is too long for the running head
\titlerunning{A methodology to develop SOEAs}
\author{P. Garc\'ia-S\'anchez, A. M. Mora, P. A. Castillo, J. Gonz\'alez and J.J. Merelo}



\authorrunning{P. Garc\'ia-S\'anchez et al.}

% (feature abused for this document to repeat the title also on left hand pages)
% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published

\institute{Dept. of Computer Architecture and Technology and CITIC-UGR \\ University of Granada, Spain 
\mailsa}


\maketitle

\blfootnote{This work has been supported in part by FPU research grant AP2009-2942 and projects SIPESCA (G-GI3000/IDIF, under Programa Operativo FEDER de Andalucía 2007-2013), PYR-2014-17 of CEI BIOTIC Granada (GENIL) and ANYSELF (TIN2011-28627-C04-02).}


\begin{abstract}
This paper proposes a methodology to design and implement Evolutionary
Algorithms using the Service Oriented Architecture paradigm. This
paradigm allows to deal with some of the shortcomings in the
Evolutionary Algorithms area, facilitating the development,
integration, standardization of services that conform a
evolutionary algorithm, and, besides, the dynamic alteration of those
elements in runtime. A four-step methodology to
design services for Evolutionary Algorithms % services that do what? - JJ FERGU: EAs
is presented: identification, specification,
implementation and deployment. Also, as an example of application of
this methodology, an adaptive algorithm is developed. % ¿cómo se
                                % valida esa metodología? Si no se
                                % valida, una metodología no vale gran
                                % cosa. Sólo llevar a cabo un ejemplo
                                % no es suficiente (y esto vale
                                % también para tu tesis) - JJ FERGU:
                                % preguntar
% ¿has preguntado? - JJ
\end{abstract}



\section{Introduction}

%Evolutionary Algorithms %, and their subtypes (Genetic Algorithms,
%Evolution Strategies or Genetic Programming, among others)
% elimino lo anterior por sobrante y por no estar de acuerdo con
% "subtypes" - JJ FERGU: ok.
% follow a number of common steps: initialization, evaluation,
% selection, recombination, mutation, replacement and stop criterion
% \cite{eiben2010whatis}. There exist many variations of these steps,
% and two different combinations can yield two different algorithms. % este  párrafo tiene obviedades, puede eliminarse - JJ FERGU: ok

% Te falta una argumentación clara. Existe este problema porque lo ha
% dicho no sé quién, esto puede ser una solución, yo voy a hacer esto
% al respecto. Quítale la morralla a la introducción y te quedas con
% "Los algoritmos evolutivos son esto, se pueden mejorar
% distribuyéndolos, hay otras líneas de investigación y hay muchos
% frameworks" WTF??? ¿Dónde están las premisas, y a qué quieres
% llegar? - JJ FERGU: ok. Creo que en la tesis lo estoy dejando más claro (creo)


%Evolutionary Algorithms (EAs) are a set of bio-inspired techniques applied to optimization problems \cite{eiben2010whatis}, based in the process of natural selection. Their classic parallelization approaches \cite{alba2002parallelism}, such as the master-slave or island-based models, have been updated with the usage of new trends such as P2P \cite{laredo2010evag} or pool-based EAs \cite{meri2013cloud}. These new approaches deal with computational nodes entering and exiting during the experiment runtime and heterogeneous architectures, that could be difficult to deal with traditional {\em development} paradigms, such as Object Oriented Programming. Other research lines, such as the parameter adaptation \cite{ParameterControlEiben07} or Memetic Algorithms \cite{ong2006classification} also imply the existence of some kind of {\em dynamism} involving the parts that compose an algorithm: for example, different recombinators or mutators working at the same time.  %Moreover, there exist several lines of parameter adaptation in dynamic and heterogeneous environments, where different computational elements are working at the same time.

%Finally, there exist a large number of different (and incompatible) frameworks for EAs, each one using different languages, technologies and communication protocols, being difficult the {\em integration} (or reuse) of their elements. As Parejo et al. suggest  in \cite{SURVEYMOFS}, a {\em standardization} of these frameworks should be carried out. Moreover, it is difficult to access, in a public way, to available public systems to execute existing EAs to validate experiments and save time, encouraging Open Science \cite{Foster2005Science}.

New trends in Evolutionary Algorithms (EAs) \cite{eiben2010whatis},
such such as P2P or pool-based EAs \cite{meri2013cloud}, lead to its
implementation in dynamic and heterogeneous environments. Service
Oriented Architecture (SOA) has been proposed
\cite{Garcia13ServiceEAs} as a possible solution to facilitate the
creation of applications in these kind of environments. % ¿Cuáles? ¿El que existan muchos frameworks? FERGU2 más cosas borradas
                         % ¿Lo ves como no está clara la línea
                         % argumental? Sólo ha quedado claro un
                         % "shortcoming" (que, además, no has
                         % justificado) -JJ FERGU reescrita la intro. Quería que los shortcomings sean los 4 esos, añadidos FERGU2: RE-REESCRITA la intro para que sea más corta y relacionada con cosas de la tesi
In this paradigm, a service is a loose, coarse-grained, and autonomous component that
allows interactions of all the elements that conform the system
\cite{Arsanjani2008SOMA}. SOA could facilitate % facilitate
                                % what? - JJ FERGU2: puesto
the creation and control of services for EAs in several issues % addressed o exposed? No los has expuesto - JJ FERGUSON: ahora sí FERGU2: ahora los problemas están explicados en cada parte
  addressed in other works, such as their use in {\em development}, as there exist several methodologies to model and design services, or the usage of techniques such as versioning, packaging or life-cycle control. Services also facilitate the {\em integration}, as they are independent of the programming language. Furthermore, services allow distribution transparency: it is not mandatory to use a specific library for the distribution, or modify the code to adapt the existing operators.  
 As SOA is based in public standards (such as
 WSDL\footnote{\url{http://www.w3.org/TR/wsdl}} or
 OSGi\footnote{\url{http://www.osgi.org/}}), its use promotes the
 {\em standardization} of the service interfaces, facilitating % of what? - JJ FERGU2: interfaces y enlazo con Open Science
 the Open Science \cite{Foster2005Science}. % a ver si es verdad, pero lo veo complicado Es un buen argumento, de todas formas, igual tendrías que empezar por ahí. - JJ FERGU: ya, pero ya es meterse a saco en otro área. Pero me lo apunto como idea para siguientes papers.
 Finally, as services are not aware of the order of execution, the
 {\em dynamism} of this paradigm can fit with new parallel approaches
 for EAs, where the control of the nodes is not centralized. For
 example, new operators in different nodes can be bound and used
 during the run of an algorithm. Also, there should be easy to add and
 remove elements to achieve self-adaptive mechanisms. All previous issues 
 are taken into consideration in this paper to propose the methodology.

  % are they? How
                                % is this addressed in this paper? - JJ FERGU: Are addressed, pero no me cabe cada elemento

%SoA ¿en qué? ¿En estandarización? ¿En frameworks? Tienes que
%establecer el marco en la introducción. ¿Por qué son importantes los
%frameworks genéricos?  - JJ FERGU: reescrito

SOA has been previously used in the EA area. For example,
web services have been used in the grid area for optimization
problems \cite{GRIDUFO}, where services are defined using WSDL. In our previous work \cite{Garcia13ServiceEAs}, an introduction to the usage of SOA to develop EAs, with some advantages, guidelines and examples was presented. However, previous works do not count with a guided step by step methodology for EAs, as proposed in this paper.

% y ahora pones
% sólo cuatro cosillas el último de los cuales es de cuando? ¿de 2004?
% El estado del arte no es poner cuatro artículos que se te ocurran,
% sino establecer qué es lo que hay para mostrar que tú has ido un
% poco más allá - JJ FERGU: reescrito

The rest of the paper is structured as follows: the description of the proposed methodology (called SOA-EA) is presented in Section \ref{sec:methodology}. Then, in Section \ref{sec:example} an example of application of the methodology to create a service oriented evolutionary algorithm is performed. Finally, conclusions and future works are discussed.

\section{Methodology}
\label{sec:methodology}

This section presents all the steps to design and implement Service Oriented Evolutionary Algorithms (SOEAs), that is, evolutionary algorithms whose elements are services. The selected steps have been adapted from SOMA \cite{Arsanjani2008SOMA}, a methodology to develop services focused on business environments and adapted to be used in the EA research area.  

This methodology also takes into account the work of Gagn\'e and Parizeau \cite{GENERICITY05}. The authors established six criteria to qualify the genericity of a framework for EAs:  generic representation, generic fitness, generic operations, generic evolutionary model, parameter management and configurable output. Also, according to Valipour \cite{Valipour09surveysoa}, services developed must follow several characteristics:  they must be discoverable and dynamically bound, self-contained and modular, interoperable, loose-coupled, transparent to location and composable.

%\begin{itemize}
%\item {\em Discoverable and Dynamically Bound}: Services must be discoverable. Thanks to the service registry, a service consumer can discover a service to be use at runtime.
%\item {\em Self-Contained and Modular}: All functions in SOA are services. This means that every
%  component in SOA must be modelled as a service, or as an aggregation of services. The services are well-defined: the interface of the service must be fixed, and it can not change in time, because the consumers or implementations of this interface should be modified with it. Services are, therefore, {\em encapsulated}: only the interface should be used to consume a service.
%\item {\em Interoperability}: Consumers do not need to know how the service implementation performs their function, as services behave as a ``black box''. This is, elements such as the programming language or distribution protocol are independent.
%\item {\em Loose Coupling}: Services should be designed to need only a few number of well-known dependencies.
%\item {\em Location Transparency}: Services must be indistinguishably local or remote, being independent of the protocol to establish the connection.
%\item {\em Composability}: Developing applications in SOA means to aggregate different existing services. Services are designed to be {\em re-usable}.
%\end{itemize}

%agh, cambio de tema. Una vez más, el esqueleto. Aquí te dejo seis
%criterios para no sé qué, características de no sé cuanto, y ahora te
%cuento cuando se ha usado SOA en algoritmos genéticos porque yo lo
%valgo. Sólo te falta el "Regarding to" - JJ FERGU: cambiado de sitio

% As in SOMA, the phases of the proposed methodology are not linear, but they are iterative and incremental, that is, the designer can move back to a previous step if necessary. For example,
% new services can be discovered during the specification phase or changes on the specification could appear in the deployment phase. Figure \ref{fig:distributed:methodology} shows the steps of the proposed methodology.



%\begin{figure}
%\begin{center}
%\includegraphics[scale=0.38]{methodology.eps}
%\end{center} 
%\caption{Methodology to develop service oriented evolutionary algorithms.}
%\label{fig:distributed:methodology}
%\end{figure}

\subsection{Identification}
\label{subsec:soaea:identification}

This phase is focused on the identification of the three constructs of SOA: services, components and flows. The developers should ask themselves several questions to facilitate the identification about the problem to solve, such as the elements and operators needed by the EA, the extension capabilities and how to parametrize of the EA. To facilitate this task three different domains are proposed. In the first one, the \textbf{algorithm domain}, the services are those that conform the EA. For example, operators of individuals, stop criterion, or populations. The second one, the \textbf{problem domain}, comprises services to address the elements of the problem (for example, the fitness function). There are also other services that depend on the problem, such as an initializer of individuals. Finally, the \textbf{infrastructure domain}, identify services that deal with the specific infrastructure that will be used to execute the algorithm. For example, services for user control, load balancing or logging. Depending on the environment where the EA is going to be developed, other services need to be modelled. For example, user control in cloud environments, different mechanisms for logging or interconnection with other systems (such as external databases).

 

\subsection{Specification}

%Once the services have been identified, the next step of the methodology establishes the inputs and outputs of the services.
 The questions to solve prior to this phase are related with the operations and their inputs/outputs, the flow (order) of services, different kinds of available implementations and adaptation of services (metrics or behaviours).

 %In this step, all the characteristics of genericity for the design of EAs \cite{GENERICITY05} should be taken. However, requirements are also aligned with the requirements for designing services \cite{Valipour09surveysoa}.



First, the EA \textbf{operators} should not be be modelled to receive one or two
individuals, but a
list of individuals to be modified, as not all EAs have the same behaviour. Since many types of individuals may exist, the operators should be as abstract as possible to work properly. Therefore, services must accept interfaces of individuals as inputs, not concrete implementations, such as vectors or lists (generic representation). This is also applied to the \textbf{fitness}: it should not be calculated within a method of an {\em Individual} class. To be less
coupled, it should be implemented as an external service that receives a list of individuals (facilitating the load balancing). % That way, the service is as abstract as possible. 

The \textbf{population} should be a service
to access the individuals and allow the variation of its structure (for example, a change
from an unique list population to a cellular model) without
affecting  the rest of the pieces of the algorithm. So, other services
external to the EA could consult the {\em population} state and act
accordingly to some rules. 






Also the \textbf{parameter} set should be a service for the same reason, allowing the possibility of performing
experiments related to  parameter control or tuning in an efficient way
(being separated from the code of the existing operators). 

 A SOEA can be seen as a service flow. The \textbf{flows} should be designed to reduce the impact of potential future changes. An example of service flow would be an implementation called {\em Evolutionary Algorithm} with all the steps common to all EAs and with independence of the implementations of these steps (generic evolutionary model). This allow the adaptation of the evolutionary model. The user can manually
  select the services to be combined to create a Genetic Algorithm or
  an Evolution Strategy, for example. Finally, the \textbf{infrastructure services} should be designed as flexible output mechanisms. For example, a GUI or logging should be independent of the services. 
  %Furthermore, to accomplish with the genericity presented by \cite{GENERICITY05}, the parameters and operators should be added dynamically. This is done with the SOA service binding. Users can specify the operators they need in several ways, for example, in a configuration file, or in an intelligent manner (an algorithm). It is important to remark that these ``pieces'' do not need to be modified and compiled again, because the loose coupling and the dynamic binding of SOA. Without SOA this behaviour is very difficult to achieve or maintain, as will be explained in next section.



%It is important to remark that in the future these services could be extended, so they should be designed taking into account this possibility.

\subsection{Implementation and deployment}
\label{subsec:soaea:implementation}
The last two steps SOA-EA are explained together because the decisions about the technological solution to be used is bound to both phases. The questions to solve in these steps are related with the technological implementation of the services and its execution (locally or remotely). Different technologies should be compared to address the publication of interfaces, overload and dynamic control. Also, considerations about security, persistence, benchmarking and monitoring are taken into account in this step.


The first step is to \textbf{select the technology to expose the interface}, depending on the use of the services. For example, a service that is going to be used remotely and publicly from any programming language should export its interface with WSDL publicly available with an URL, to allow users to automatically generate the client for that service. On the other side, interfaces could be previously known, and it is not necessary to export them to the public. This is the case of OSGi, where the interface is exposed only to the OSGi service registry.%, although other mechanisms could be used to publish and share the interfaces of the services. %(for example, using a {\em newcast} protocol).

%Services are also independent of the transmission mechanism, so this issue

The \textbf{selection of the communication mechanism} must be considered depending on the system to deploy the services. In the case of EAs, where the performance is important, usually the most efficient transmission mechanism should be preferred. In this step, issues related with testing, user control, security and persistence should be taken into account. %For example, SOAP includes extra information in headers \cite{Castillo13SOAP}, producing more network overload. However, this information is easier to manage for other systems, or easier to configure to be used remotely (as it uses a standard HTTP port).





\section{Example of creating a service oriented evolutionary algorithm}
\label{sec:example}
This section justifies the use of the proposed methodology and the steps to create services with it. In this example, a basic genetic algorithm to solve the MMDP problem \cite{goldberg92massive} will be designed. This algorithm needs to automatically bind new operators (not previously known) when the algorithm has found a local optimum. No extra code should be added to the algorithm to bind/unbind operators or check the population.



In the {\em identification} step a number of abstract services have been identified. In the {\em algorithm domain}, the Algorithm, Population, Parent Selector, Recombinator, Mutator, Replacer, Stop Criterion and Parameters. In the {\em problem domain}, the Fitness Calculator and Initializer. Finally, a {\em infrastructure domain} service called  Asynchronous Enabler, which is in charge of activating new operators when a local optimum is found (for example, no changes in best individual during certain time).

Concrete implementations are defined in the {\em specification} step: {\em N Tournament} and {\em Roulette} are implementations of parent selectors and {\em Optimum Found} the desired stop criterion. Also, to address the problem to be solved, such as {\em MMDP Fitness Calculator} or {\em Binary Initializer}. As we need a fixed set of steps, a {\em Evolutionary Algorithm} service is created to model the flow of services. The discovered services have been specified to accept  a list of individuals. A service to gather all selectors in the environment is used. Infrastructure services to deal with control of the population and to enable other operators are also implemented (Asynchronous Enabler Imp). Figure \ref{fig:enabler} shows this designed configuration.

 \begin{figure}[tb]
\begin{center}
\includegraphics[scale=0.4]{enabler.eps}
\end{center} 
\caption{Automatic binding of new operators. White boxes are interfaces and shaded boxes are implementations of the services.}
\label{fig:enabler}
\end{figure}

\begin{figure}[tb]
    \centering

   
    

      \begin{tabular}{ccc}

      \multirow{8}{*}{\includegraphics[scale=0.25]{datos.eps}}\\ \cline{2-3}
      &\multicolumn{2}{c}{{\em Non-adaptive}}   \\ \cline{2-3}
      &Generations & 219403,10 $\pm$ 141692,16      \\ \cline{2-3}
      &Evaluations & 14041926,40 $\pm$ 9068298,82   \\ \cline{2-3}
      &Time    & 68766,40 $\pm$ 45073,04     \\  \cline{2-3}
      &\multicolumn{2}{c}{{\em Adaptive}} \\  \cline{2-3}
      &Generations &  167166,66 $\pm$ 93594,37 \\  \cline{2-3}
      &Evaluations & 10698794,66 $\pm$ 5990039,68 \\  \cline{2-3}
      &Time &    51710,40 $\pm$ 29329,21 \\  \cline{2-3}
      \\
      \\
      \end{tabular}      
  

  
      %\hfill\includegraphics[scale=0.25]{datos.eps}\hfill\null
    

\caption{Results obtained. The version with automatic binding of services achieved significant better results.} % in what? Why are they important? What do
                            % they mean? Are they significantly
                            % different? - JJ FERGU: comentado más
\label{fig:results}
\end{figure}

 Since this example requires automatic binding and asynchronous and parallel control of the population services, OSGi is the technology proposed in the {\em implementation} step. The reasons of using these technologies are explained in \cite{Garcia13ServiceEAs}, but summarizing, OSGi allows automatically binding of implementations to interfaces without extra code or recompiling, and dynamic discovery of services, as this example requires. The source code of the proposed implementation is available under a GNU/LGPL V3 license in our repository at \url{http://www.osgiliath.org}.

Two configuration have been compared: a non-adaptive version that only uses a Binary Tournament for Selection, and an adaptive one, which automatically enables a Roulette Selection when a local optimum is found. The parameters used in this comparison (accessed from the Parameters service) are a population of 64 individuals, selector rate of 0.5, TPX crossover, bit flip mutation, and individual length of 60 genes. The Roulette selector is enabled when the best individual of the population has not changed in 10 seconds (checked every 2 seconds). Figure \ref{fig:results} shows the results obtained from the 30 executions of the two configurations tested. As it can be seen, automatic and adaptive enabling of selection operators has allowed an increase of performance, reducing time and evaluations (both significantly with a p-value$<$0.05 of a Wilcoxon test). This example has been used to demonstrate that applying a methodology to develop loose coupled services that can be dynamically bound, without modification of the existing services, can be used to achieve better results.









\section{Conclusions}
\label{sec:conclusion}

 %There exist several shortcomings in the Evolutionary Algorithms area,
 %such as the  incompatibility between frameworks or how to handle with
 New trends in distributed Evolutionary Algorithms, such as P2P, imply to deal 
 with heterogeneous and dynamic environments, with different programming languages and transmission technologies. This fact  motivate the creation of a proper way to define service oriented evolutionary algorithms (SOEAs) to facilitate
 the development, integration, standardization and dynamism of the EA components in this kind of environments. In this paper the requirements in EA design, with the requirements in SOA, have been taken into account to propose a methodology to model the services that compose a service oriented EA, and several guidelines about the design of these services have been explained. This methodology, called SOA-EA, proposes four iteratively and incremental phases: identification, specification, implementation and deployment.  SOA-EA has been used to create a SOEA that takes advantage of the SOA capabilities, such as loose-coupled services and automatic binding of new operators.

In future work, this methodology will be used to create new examples of SOEAs and refined to deal with other shortcomings. Other technologies available in SOA will be also tested and analysed.




\bibliographystyle{splncs}
\bibliography{soaea}



\end{document}

